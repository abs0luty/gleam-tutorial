<!DOCTYPE HTML>
<html lang="en" class="latte sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Gleam programming language</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./theme/catppuccin.css">
        <link rel="stylesheet" href="./theme/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "latte";
            const default_dark_theme = "mocha";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('latte')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="latte">Latte</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="frappe">Frappé</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="macchiato">Macchiato</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mocha">Mocha</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Gleam programming language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/abs0luty/gleam-tutorial" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="what-is-gleam"><a class="header" href="#what-is-gleam">What is Gleam?</a></h2>
<p><strong>Gleam</strong> is a modern, friendly programming language for building type-safe and scalable systems. It compiles to <a href="http://www.erlang.org/">Erlang</a> and JavaScript, and integrates seamlessly with other BEAM languages like Erlang, Elixir, and LFE.</p>
<p>A simple Gleam program looks like this:</p>
<pre><code class="language-gleam">import gleam/io

pub fn main() {
  io.println("hello, world!")
}
</code></pre>
<p>Gleam combines the guarantees of a strong type system, the expressiveness of functional programming, and the reliability of the highly concurrent Erlang runtime.</p>
<h2 id="reliability-and-scalability"><a class="header" href="#reliability-and-scalability">Reliability and scalability</a></h2>
<p>Running on the Erlang virtual machine - the same platform behind large-scale systems such as WhatsApp - Gleam is built for production workloads of any size.</p>
<p>The BEAM runtime enables:</p>
<ul>
<li>Multi-core, actor-based concurrency with millions of lightweight processes.</li>
<li>Immutable data structures for safe parallelism.</li>
<li>A concurrent garbage collector that never pauses the entire system.</li>
</ul>
<pre><code class="language-gleam">fn spawn_task(i) {
  task.async(fn() {
    let n = int.to_string(i)
    io.println("Hello from " &lt;&gt; n)
  })
}

pub fn main() {
  list.range(0, 200_000)
  |&gt; list.map(spawn_task)
  |&gt; list.each(task.await_forever)
}
</code></pre>
<h2 id="use-syntax"><a class="header" href="#use-syntax">Use syntax</a></h2>
<p>Gleam's <code>use</code> syntax lets you write callback-based APIs in a flat, top-to-bottom style, killing the "pyramid of doom".</p>
<p>It's pure syntax sugar that rewrites the rest of the block into an anonymous function passed to the callee, so you keep the same semantics (no new runtime magic) but lose the nesting - making control flow and error cases much easier to read and maintain:</p>
<pre><code class="language-gleam">pub fn with_use() -&gt; Result(String, Nil) {
  use username &lt;- result.try(get_username())
  use password &lt;- result.try(get_password())
  use greeting &lt;- result.map(log_in(username, password))
  greeting &lt;&gt; ", " &lt;&gt; username
}
</code></pre>
<p>Without <code>use</code>, the same logic requires nested anonymous functions:</p>
<pre><code class="language-gleam">pub fn without_use() -&gt; Result(String, Nil) {
  result.try(get_username(), fn(username) {
    result.try(get_password(), fn(password) {
      result.map(log_in(username, password), fn(greeting) {
        greeting &lt;&gt; ", " &lt;&gt; username
      })
    })
  })
}
</code></pre>
<h2 id="built-in-tools"><a class="header" href="#built-in-tools">Built-in tools</a></h2>
<p>Gleam ships with everything you need: a compiler, build tool, formatter, package manager, and editor integrations. Starting a new project is as simple as:</p>
<pre><code>gleam new my_project
</code></pre>
<p>The ecosystem includes thousands of packages from Gleam, Erlang, and Elixir. For example:</p>
<pre><code>➜ gleam add gleam_json
      Added gleam_json v0.5.0
➜ gleam test
   Running app_test.main
.
1 tests, 0 failures
</code></pre>
<h2 id="developer-friendly"><a class="header" href="#developer-friendly">Developer-friendly</a></h2>
<p>Gleam avoids common pitfalls like null values and exceptions. Its type system and error messages are designed to be practical and approachable:</p>
<pre><code>error: Unknown record field

  ┌─ ./src/app.gleam:8:16
  │
8 │ user.alias
  │     ^^^^^^ Did you mean `name`?

The value being accessed has this type:
    User

It has these fields:
    .name
</code></pre>
<h2 id="interoperability"><a class="header" href="#interoperability">Interoperability</a></h2>
<p>Gleam works smoothly with other BEAM languages, giving you access to a vast ecosystem of libraries. It can also compile to JavaScript, complete with TypeScript definitions for safe interoperability.</p>
<pre><code class="language-gleam">@external(erlang, "Elixir.HPAX", "new")
pub fn new(size: Int) -&gt; Table

pub fn register_event_handler() {
  let el = document.query_selector("a")
  element.add_event_listener(el, fn() {
    io.println("Clicked!")
  })
}
</code></pre>
<h2 id="learn-more"><a class="header" href="#learn-more">Learn more</a></h2>
<ul>
<li><a href="https://gleam.run/book/tour/">Language tour</a></li>
<li><a href="https://gleam.run">Official website</a></li>
<li><a href="https://discord.com/invite/Fm8Pwmy">Discord server</a></li>
<li><a href="https://github.com/gleam-lang">Github</a></li>
<li><a href="https://gleam.run/documentation#cheatsheets">Cheat sheets for:</a>
<ul>
<li><a href="https://gleam.run/cheatsheets/gleam-for-elixir-users/">Elixir users</a>, <a href="https://gleam.run/cheatsheets/gleam-for-elm-users">Elm users</a>, <a href="https://gleam.run/cheatsheets/gleam-for-erlang-users">Erlang users</a></li>
<li><a href="https://gleam.run/cheatsheets/gleam-for-php-users">PHP users</a>, <a href="https://gleam.run/cheatsheets/gleam-for-python-users">Python users</a>, <a href="https://gleam.run/cheatsheets/gleam-for-rust-users">Rust users</a></li>
</ul>
</li>
<li><a href="https://github.com/gleam-lang/awesome-gleam">Awesome Gleam resource list</a></li>
<li><a href="https://hexdocs.pm/gleam_stdlib/">Standard library documentation</a></li>
<li><a href="https://packages.gleam.run/">Gleam package index</a></li>
<li><a href="https://gleam.run/writing-gleam/gleam-toml/"><code>gleam.toml</code> file reference</a></li>
<li><a href="https://gleam.run/writing-gleam/command-line-reference/">Command line reference (for <code>gleam</code> command)</a></li>
<li><a href="https://erlangforums.com/c/beam-language-forums/gleam-forum/36">Gleam's threads on the Erlang Forums</a></li>
<li><a href="https://github.com/gleam-lang/gleam/discussions">Gleam discussions on Github</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="installing-erlang"><a class="header" href="#installing-erlang">Installing Erlang</a></h2>
<p>Since Gleam primarily compiles to Erlang (with optional JavaScript support), you'll need Erlang installed on your system first.</p>
<p><strong>On Linux and macOS:</strong></p>
<ul>
<li><strong>Homebrew (macOS):</strong> <code>brew install erlang</code></li>
<li><strong>MacPorts (macOS):</strong> <code>port install erlang</code></li>
<li><strong>Ubuntu/Debian:</strong> <code>apt-get install erlang</code></li>
<li><strong>Fedora:</strong> <code>yum install erlang</code></li>
<li><strong>Arch Linux/Manjaro:</strong> <code>pacman -S erlang</code></li>
<li><strong>FreeBSD:</strong> <code>pkg install erlang</code></li>
</ul>
<p><strong>On Windows:</strong>
Download and install Erlang using the official installers:</p>
<ul>
<li><a href="https://github.com/erlang/otp/releases/download/OTP-26.1.2/otp_win64_26.1.2.exe">64-bit</a></li>
<li><a href="https://github.com/erlang/otp/releases/download/OTP-26.1.2/otp_win32_26.1.2.exe">32-bit</a></li>
</ul>
<h2 id="installing-gleam"><a class="header" href="#installing-gleam">Installing Gleam</a></h2>
<p>The simplest way to get Gleam is from the <a href="https://github.com/gleam-lang/gleam/releases">GitHub releases page</a>.
Download the latest release for your operating system and follow the installation instructions.</p>
<h2 id="building-from-source"><a class="header" href="#building-from-source">Building from Source</a></h2>
<p>You may want to build Gleam from source if you’re contributing to the language or compiling it for WebAssembly.</p>
<ol>
<li>
<p><strong>Clone the repository:</strong></p>
<pre><code class="language-sh">git clone https://github.com/gleam-lang/gleam
cd gleam
</code></pre>
</li>
<li>
<p><strong>Install Rust:</strong>
Gleam’s compiler is written in Rust. Install it via <code>rustup</code>:</p>
<ul>
<li>
<p><strong>Linux/macOS:</strong></p>
<pre><code class="language-sh">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
</li>
<li>
<p><strong>Windows:</strong>
Download the installer from the <a href="https://forge.rust-lang.org/infra/other-installation-methods.html">Rust website</a>, run it, then use:</p>
<pre><code class="language-sh">rustup toolchain install stable
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Build the compiler:</strong></p>
<pre><code class="language-sh">cargo install --path gleam-bin 
</code></pre>
<p>This installs Gleam globally on your system.</p>
</li>
</ol>
<h2 id="building-for-webassembly"><a class="header" href="#building-for-webassembly">Building for WebAssembly</a></h2>
<p>To compile Gleam for WebAssembly, install <code>wasm-pack</code>:</p>
<ul>
<li>
<p><strong>Linux/macOS:</strong></p>
<pre><code class="language-sh">curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh
</code></pre>
</li>
<li>
<p><strong>Windows (alternative):</strong></p>
<pre><code class="language-sh">cargo install wasm-pack
</code></pre>
</li>
</ul>
<p>Then build the WebAssembly target:</p>
<pre><code class="language-sh">cd compiler-wasm
wasm-pack build --target web
</code></pre>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello world</a></h2>
<p>Let us now write our first Gleam program! <em>If you don't have Gleam installed, it is recommended to follow instructions in the <a href="./installation.html">previous section</a></em>. Run:</p>
<pre><code>gleam new hello_world
cd hello_world
</code></pre>
<p>You can now see the automatically generated Gleam project structure:</p>
<pre><code>hello_world
|_ .github/workflows
   |_ test.yml
|_ src
   |_ hello_world.gleam
|_ test
   |_ hello_world_test.gleam
|_ .gitignore
|_ gleam.toml
|_ README.md
</code></pre>
<p>The entry point is located in the <code>src/hello_world.gleam</code> file. It will probably look something like this:</p>
<pre><code class="language-gleam">import gleam/io

pub fn main() {
  io.println("Hello from hello_world!")
}
</code></pre>
<p>Let us change our program, so that it prints canonical <code>Hello, world!</code> message:</p>
<pre><code class="language-gleam">import gleam/io

pub fn main() {
  io.println("Hello, world!")
}
</code></pre>
<p>As you can see, Gleam doesn't require semicolons. To run the program, you can use <code>gleam run</code> command:</p>
<pre><code>$ gleam run
  Compiling gleam_stdlib
  Compiling gleeunit
  Compiling hello_world
   Compiled in 1.78s
    Running hello_world.main
Hello, world!
</code></pre>
<p>By default, it transpiles our code to erlang and uses it to run our code. However, you can also use javascript using <code>--target</code> flag:</p>
<pre><code>$ gleam run --target javascript
  Compiling gleam_stdlib
  Compiling gleeunit
  Compiling hello_world
   Compiled in 1.5s
    Running hello_world.main
Hello, world!
</code></pre>
<p>You can also use specific javascript runtime using <code>--runtime</code> flag:</p>
<pre><code>$ gleam run --target javascript --runtime node
  Compiling gleam_stdlib
  Compiling gleeunit
  Compiling hello_world
   Compiled in 1.5s
    Running hello_world.main
Hello, world!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="who-this-tutorial-is-made-for"><a class="header" href="#who-this-tutorial-is-made-for">Who this tutorial is made for</a></h2>
<p>This tutorial is for people who’ve written code before and don’t need hand-holding on the absolute basics. If you already know what variables, functions, types, and control flow are, you’re in the right place.</p>
<p>We'll go fast on "intro to programming" stuff and focus on how BEAM and Gleam do things.</p>
<p>You <strong>don't</strong> need prior functional-programming experience. If you’ve mostly lived in Python/JS/Go/C++ and you're curious about a friendly functional language on the BEAM, you'll be fine. Plenty of respected language guides set similar expectations - for example, <em>Learn You a Haskell</em> explicitly targets people who've programmed before but are new to FP, which is the same vibe we're going for. (<a href="https://learnyouahaskell.com" title="Learn You a Haskell for Great Good!">learnyouahaskell.com</a>)</p>
<p>Think of this as a practical, programmer-to-programmer tour. Like the Go Tour and the Rust Book, we'll move quickly from syntax to real patterns and habits, assuming you can already read code and run tools; the goal is to level up how you build, not teach what a loop is. (<a href="https://go.dev/tour" title="A Tour of Go">Go.dev</a>)</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<p>Let us now modify our previous hello world program:</p>
<pre><code class="language-gleam">import gleam/io

pub fn main() {
  // Print hello world
  io.println("Hello world!")
}
</code></pre>
<p>Gleam allows you to write comments in your code by prefixing them with <code>//</code>:</p>
<pre><code class="language-gleam">// Hello, world! I have a lot to say, so much that it will take multiple
// lines of text. Therefore, I will start each line with // to denote it
// as part of a multi-line comment.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="booleans"><a class="header" href="#booleans">Booleans</a></h2>
<p>In Gleam, boolean literals are either <code>True</code> or <code>False</code>. Their type is <code>Bool</code>. You can apply binary operations on these boolean values, such as:</p>
<pre><code class="language-gleam">False &amp;&amp; False // =&gt; False
True &amp;&amp; False  // =&gt; False
True &amp;&amp; True   // =&gt; True

False || False // =&gt; False
True || False  // =&gt; True
True || True   // =&gt; True
</code></pre>
<p><code>&amp;&amp;</code> is logical <strong>AND</strong>: it returns <code>True</code> only if <em>both</em> operands are <code>True</code>.</p>
<p><code>||</code> is logical <strong>OR</strong>: it returns <code>False</code> only if <em>both</em> operands are <code>False</code>.</p>
<p>Both <code>&amp;&amp;</code> and <code>||</code> short‐circuit:</p>
<ul>
<li><code>&amp;&amp;</code> does not evaluate its right operand if the left is <code>False</code>, since the result is already known to be <code>False</code>.</li>
<li><code>||</code> does not evaluate its right operand if the left is <code>True</code>, since the result must be <code>True</code>.</li>
</ul>
<p>Here is an example of such behaviour:</p>
<pre><code class="language-gleam">import gleam/io

fn foo() -&gt; Bool {
  io.println("test")
  True
}

pub fn main() {
  let _ = False &amp;&amp; foo()
}
</code></pre>
<p>In this case <code>test</code> isn't printed because <code>False &amp;&amp; ...</code> immediately yields <code>False</code> without calling <code>test()</code>. If instead you write:</p>
<pre><code class="language-gleam">import gleam/io

fn test() -&gt; Bool {
  io.println("test")
  True
}

pub fn main() {
  let _ = True &amp;&amp; test()
}
</code></pre>
<p>Output:</p>
<pre><code>test
</code></pre>
<p>Because the left side (<code>True</code>) doesn't block evaluation, so <code>test()</code> is called.</p>
<h3 id="printing-booleans"><a class="header" href="#printing-booleans">Printing Booleans</a></h3>
<p>If you want to print a <code>Bool</code>, you must first convert it to a <code>String</code> using <code>bool.to_string</code>. For example:</p>
<pre><code class="language-gleam">import gleam/io
import gleam/bool

pub fn main() {
  io.println(bool.to_string(True))
}
</code></pre>
<p>Output:</p>
<pre><code>True
</code></pre>
<p>Alternatively, for debugging you can use <code>echo</code>:</p>
<pre><code class="language-gleam">import gleam/io

pub fn main() {
  echo False
  echo "True"
}
</code></pre>
<p>Output:</p>
<pre><code>src/main.gleam:4
False
src/main.gleam:5
"True"
</code></pre>
<h3 id="negation"><a class="header" href="#negation">Negation</a></h3>
<p>You can negate booleans in two ways:</p>
<ul>
<li>Using the <code>!</code> operator: <code>!True</code> → <code>False</code>, <code>!False</code> → <code>True</code></li>
<li>Using <code>bool.negate</code> from the <code>gleam/bool</code> module:</li>
</ul>
<pre><code class="language-gleam">import gleam/io
import gleam/bool

pub fn main() {
  echo !True
  echo bool.negate(False)
}
</code></pre>
<p>Output:</p>
<pre><code>src/main.gleam:4
False
src/main.gleam:5
True
</code></pre>
<h3 id="pipelines"><a class="header" href="#pipelines">Pipelines</a></h3>
<p>It's common in Gleam to compose function calls using the <strong>pipe operator</strong>:</p>
<pre><code class="language-gleam">import gleam/io
import gleam/bool

pub fn main() {
  True
  |&gt; bool.to_string
  |&gt; io.println
}
</code></pre>
<p>This does the same as:</p>
<pre><code class="language-gleam">io.println(bool.to_string(True))
</code></pre>
<p>We'll dive deeper in <a href="basics//basics/functions.html#pipelines">later sections of this tutorial</a>.</p>
<h2 id="numbers"><a class="header" href="#numbers">Numbers</a></h2>
<p>Gleam has two numeric types: <strong><code>Int</code></strong> for whole numbers and <strong><code>Float</code></strong> for fractional values.</p>
<ul>
<li>
<p>On the <strong>BEAM</strong> target, <code>Int</code> values are arbitrary-precision integers (limited only by memory). Small integers are optimized; larger ones transparently become bignums. <code>Float</code> is the runtime’s 64-bit IEEE-754 double, but BEAM has no <code>NaN</code>/<code>Infinity</code> values exposed in the same way as JavaScript.</p>
<p>Dividing by zero would normally crash in Erlang, but Gleam defines division by zero to return <code>0</code> for operators and offers checked functions in the stdlib.</p>
</li>
<li>
<p>On the <strong>JavaScript</strong> target, <code>Float</code> is a 64-bit IEEE-754 double, matching JS <code>Number</code>. <code>Int</code> operations obey the host’s numeric semantics; keep integers within JS’s <strong>safe integer</strong> range (±(2^53−1)) to avoid precision loss, or use library types/BigInt when you need larger exact integers.</p>
<p>Gleam’s stdlib exposes the same checked APIs (<code>int.divide</code>, <code>float.divide</code>, etc.).</p>
<blockquote>
<p>Tip: If you depend on integers exceeding the JS safe range, prefer algorithms that avoid huge intermediates, or use a BigInt-backed approach via <a href="https://hexdocs.pm/bigi/index.html">the library designed for JS target</a>.</p>
</blockquote>
</li>
</ul>
<h3 id="integers"><a class="header" href="#integers">Integers</a></h3>
<p>Here are some examples of integer literals in Gleam:</p>
<pre><code class="language-gleam">0
1
3
-4
2942930103
</code></pre>
<p>Gleam supports <code>_</code> in integers for clarity:</p>
<pre><code class="language-gleam">3_000_000 vs 3000000
10_000_000 vs 10000000
20_000_000_000 vs 20000000000
</code></pre>
<p>The <code>_</code> has no syntactic and semantic meaning. Gleam as many other languages also supports integers in different bases: binary, octal and hexadecimal integers start with <code>0b</code>, <code>0o</code> and <code>0x</code> respectively:</p>
<pre><code class="language-gleam">0b0101000101
0o712
0xFf // `f` and `F` here are the same
</code></pre>
<p>Gleam supports basic primitive operations with integers:</p>
<pre><code class="language-gleam">1 + 3 - 2 * 4 // =&gt; -4
7 / 2  // =&gt; 3 (rounded)
3 % 2  // =&gt; 1
1 &gt; 0  // =&gt; True
1 &lt; 0  // =&gt; False
1 &gt;= 0 // =&gt; True
1 &lt;= 0 // =&gt; False
</code></pre>
<blockquote>
<p><strong>Note</strong>: In Gleam division between integers returns another integer, which is the result of the division rounded down.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: In Gleam division returns <code>0</code> when divisor is <code>0</code>:</p>
<pre><code class="language-gleam">2 / 0 // =&gt; 0
1 / 0 // =&gt; 0
0 / 0 // =&gt; 0
</code></pre>
<p>This is why it is generally recommended to use <code>int.divide</code> function which returns an error if the divisor is <code>0</code>:</p>
<pre><code class="language-gleam">5 |&gt; int.divide(2) // =&gt; Ok(2)
5 |&gt; int.divide(0) // =&gt; Error(Nil)
0 |&gt; int.divide(0) // =&gt; Error(Nil)
</code></pre>
</blockquote>
<p>To print the integer in Gleam, you need to first convert it to string. You can do that using <code>int.to_string</code> function:</p>
<pre><code class="language-gleam">import gleam/io
import gleam/int

fn main() {
  io.println(3 |&gt; int.to_string)
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: As mentioned before, there is a difference in how integers work for javascript and erlang targets, including converting big integers to strings. Here's an example:</p>
<pre><code class="language-gleam">import gleam/io
import gleam/int

fn main() {
  io.println(9_999_999_999_999_999 |&gt; int.to_string)
}
</code></pre>
<p>Output when running the code using default erlang target (<code>gleam run</code>):</p>
<pre><code>9999999999999999
</code></pre>
<p>Output when running the code using javascript target (<code>gleam run --target javascript</code>):</p>
<pre><code>10000000000000000
</code></pre>
<p>As of recently, Gleam compiler started to output a warning when dealing with big numbers in JS target:</p>
<pre><code>warning: Int is outside JavaScript's safe integer range
  ┌─ /Users/adi.salimgereyev/hello_world/src/hello_world.gleam:5:14
  │
5 │   io.println(9_999_999_999_999_999 |&gt; int.to_string)
  │              ^^^^^^^^^^^^^^^^^^^^^ This is not a safe integer value on JavaScript

This integer value is too large to be represented accurately by
JavaScript's number type. To avoid this warning integer values must be in
the range -(2^53 - 1) - (2^53 - 1).

See JavaScript's Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER
properties for more information.
</code></pre>
</blockquote>
<p>You can find the absolute value of the integer using <code>int.absolute_value</code> function:</p>
<pre><code class="language-gleam">-12 |&gt; int.absolute_value // =&gt; 12
12  |&gt; int.absolute_value // =&gt; 12
0   |&gt; int.absolute_value // =&gt; 0
</code></pre>
<p>If you want the result of the base being raised to the power of exponent, you can use <code>power</code> function:</p>
<pre><code class="language-gleam">3 |&gt; int.power(of: 2.0) // =&gt; 9
2 |&gt; int.power(of: 2.0) // =&gt; 4
2 |&gt; int.power(of: 4.0) // =&gt; 16
</code></pre>
<blockquote>
<p><strong>Note</strong>: <code>power</code> accepts second argument only as floating point number. Gleam doesn't have implicit <code>Int</code> to <code>Float</code> cast:</p>
<pre><code>error: Type mismatch
   ┌─ /gleam-tutorial/hello_world/src/hello_world.gleam
   │
   │  3 |&gt; int.power(of: 2)
   │                     ^

Expected type:

    Float

Found type:

    Int
</code></pre>
<p>So <code>2</code> must be changed to <code>2.0</code>. See the <a href="basics/booleans-and-numbers.html#floats">floating point numbers section</a> below.</p>
</blockquote>
<p>If you want to convert an integer to float, you can use <code>to_float</code> function:</p>
<pre><code class="language-gleam">3  |&gt; to_float // 3.0
-3 |&gt; to_float // -3.0
0  |&gt; to_float // 0.0
</code></pre>
<p>Here are some other useful methods for integers:</p>
<pre><code class="language-gleam">// Returns the minimum of two numbers
int.min(2, 3)    // =&gt; 2

// Returns the maximum of two numbers
int.max(3, 4)    // =&gt; 4

// Returns true if the number is even
2 |&gt; int.is_even // =&gt; True
3 |&gt; int.is_even // =&gt; False

// Returns true if the number is odd
2 |&gt; int.is_odd  // =&gt; False
3 |&gt; int.is_odd  // =&gt; True

// Returns the negative of the number
1 |&gt; int.negate  // =&gt; -1

// Returns the square root of the number
4   |&gt; int.square_root // =&gt; Ok(2.0)
-16 |&gt; int.square_root // =&gt; Error(Nil)
</code></pre>
<p>You can convert integers to different common bases:</p>
<pre><code class="language-gleam">2  |&gt; to_base2 // =&gt; "10"
15 |&gt; to_base8 // =&gt; "17"
48 |&gt; to_base16 // =&gt; "30"
48 |&gt; to_base36 // =&gt; "1C"
</code></pre>
<p>If you want to convert a number to any base from <code>2</code> to <code>36</code>, you can use <code>to_base_string</code>:</p>
<pre><code class="language-gleam">// 37 is bigger than 36
48 |&gt; to_base_string(37) // =&gt; Error(InvalidBase)

// 1 is less than 2
48 |&gt; to_base_string(1)  // =&gt; Error(InvalidBase)

// Same as running to_base36()
48 |&gt; to_base_string(36) // =&gt; Ok("1C")
</code></pre>
<h3 id="floats"><a class="header" href="#floats">Floats</a></h3>
<p>Here are some examples of float literals:</p>
<pre><code class="language-gleam">1.6
-0.3
8.0
</code></pre>
<p>As for integers, Gleam supports <code>_</code> in floats for clarity:</p>
<pre><code class="language-gleam">3.141_159_265
</code></pre>
<blockquote>
<p><strong>Note</strong>: you cannot put <code>_</code> before <code>.</code>:</p>
<pre><code>error: Syntax error
   ┌─ .../hello_world/src/hello_world.gleam
   │
   │     -0_.3_3
   │       ^ Numbers cannot have a trailing underscore

Hint: remove it.
</code></pre>
</blockquote>
<p>You can also use scientific notation with floats:</p>
<pre><code class="language-gleam">2.997e8
6.626e-34
</code></pre>
<blockquote>
<p><strong>Note</strong>: In Gleam operators like <code>+</code>, <code>-</code>, <code>*</code> and <code>/</code> cannot be used for floats. Instead use <code>+.</code>, <code>-.</code>, <code>*.</code> and <code>/.</code>:</p>
<pre><code class="language-gleam">2.0 +. 2.0 // =&gt; 4.0
3.0 -. 2.0 // =&gt; 1.0
1.0 *. 2.0 // =&gt; 2.0
3.0 /. 2.0 // =&gt; 1.5

// As with integers
2.0 /. 0.0 // =&gt; 0.0
0.0 /. 0.0 // =&gt; 0.0
</code></pre>
</blockquote>
<blockquote>
<p><strong>Note</strong>: Situation is a little more complex with comparison operators. <code>==</code> and <code>!=</code> work for both integers and floats. <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code> however only work for integers. So you need to use analogs: <code>&gt;.</code>, <code>&lt;.</code>, <code>&gt;=.</code>, <code>&lt;=.</code>:</p>
<pre><code class="language-gleam">2.0 &gt;.  1.0  // =&gt; True
2.0 &lt;=. 2.0  // =&gt; True
2.0 &lt;.  2.0  // =&gt; True
2.0 ==  2.0  // =&gt; True
2.0 !=  2.0  // =&gt; False
</code></pre>
</blockquote>
<blockquote>
<p><strong>Note</strong>: In Gleam, as with integers, division returns <code>0.0</code> when divisor is <code>0.0</code>:</p>
<pre><code class="language-gleam">2.0 /. 0.0 // =&gt; 0.0
1.0 /. 0.0 // =&gt; 0.0
0.0 /. 0.0 // =&gt; 0.0
</code></pre>
<p>This is why it is generally recommended to use <code>float.divide</code> function which returns an error if the divisor is 0:</p>
<pre><code class="language-gleam">import gleam/float

5.0 |&gt; float.divide(2.0) // =&gt; Ok(2.5)
5.0 |&gt; float.divide(0.0) // =&gt; Error(Nil)
0.0 |&gt; float.divide(0.0) // =&gt; Error(Nil)
</code></pre>
</blockquote>
<p>You can find the absolute value of the float using <code>float.absolute_value</code> function:</p>
<pre><code class="language-gleam">-12.0 |&gt; float.absolute_value // =&gt; 12.0
12.0  |&gt; float.absolute_value // =&gt; 12.0
0.0   |&gt; float.absolute_value // =&gt; 0.0
</code></pre>
<p>You can also round float number to the next lowest or the next highest whole number using <code>ceiling</code> and <code>floor</code> functions:</p>
<pre><code class="language-gleam">2.3 |&gt; float.ceiling // =&gt; 3.0
2.3 |&gt; float.floor   // =&gt; 2.0
</code></pre>
<p>Or you can round to the nearest whole number using <code>round</code>:</p>
<pre><code class="language-gleam">2.3 |&gt; float.round // =&gt; 2.0
2.5 |&gt; float.round // =&gt; 3.0
</code></pre>
<p>Here are some other useful methods for floats:</p>
<pre><code class="language-gleam">// Returns the minimum of two numbers
float.min(2.0, 3.3)             // =&gt; 2.0

// Returns the maximum of two numbers
float.max(3.1, 4.2)             // =&gt; 4.2

// Returns the negative of the number
1.0 |&gt; float.negate             // =&gt; -1.0

// Returns the value as `Int`, truncating all decimal digits
2.4287898428 |&gt; float.truncate  // =&gt; 2

// Returns the results of the base being raised to the power of the exponent
2.0  |&gt; float.power(-1.0)    // =&gt; Ok(0.5)
2.0  |&gt; float.power(2.0)     // =&gt; Ok(4.0)
4.0  |&gt; float.power(of: 2.0) // =&gt; Ok(16.0)
-1.0 |&gt; float.power(0.5)     // =&gt; Error(Nil)

// Returns the square root
4.0   |&gt; float.square_root   // =&gt; Ok(2.0)
-16.0 |&gt; float.square_root   // =&gt; Error(Nil)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="strings"><a class="header" href="#strings">Strings</a></h2>
<p>In Gleam, <strong>strings are UTF-8 binaries</strong>. They're immutable and can hold any Unicode text. Gleam aims for <strong>grapheme-aware</strong> behavior by default (the "user-visible characters" you expect), so things like length, reversing, and slicing won't split a character in half even when it's composed of multiple code points.</p>
<ul>
<li>On the <strong>BEAM</strong> target, strings are UTF-8 binaries and Erlang's Unicode-aware functions back a lot of the heavy lifting. (<a href="https://www.erlang.org/doc/apps/stdlib/unicode_usage.html" title="Using Unicode in Erlang  -  stdlib v7.0.2">Erlang.org</a>)</li>
<li>On the <strong>JavaScript</strong> target, the host uses UTF-16 code units under the hood, but Gleam's stdlib gives you grapheme-aware APIs so you don't have to reason in code units. (<a href="https://unicode.org/reports/tr29/" title="UAX #29: Unicode Text Segmentation">MDN Web Docs</a>)</li>
</ul>
<p>Strings use double quotes and typical escapes (<code>\"</code>, <code>\\</code>, <code>\n</code>, <code>\t</code>, <code>\u{...}</code>). Concatenate with <code>&lt;&gt;</code>:</p>
<pre><code class="language-gleam">"Hello, Gleam!\n" &lt;&gt; "\u{1F44B}"  // "Hello, Gleam! 👋"
</code></pre>
<h3 id="check-emptiness--length"><a class="header" href="#check-emptiness--length">Check emptiness &amp; length</a></h3>
<p><code>string.is_empty</code> is a fast, zero-allocation check.</p>
<p><code>string.length</code> counts <strong>graphemes</strong> (linear time because it must walk boundaries).</p>
<p><code>string.byte_size</code> reports the <strong>UTF-8 byte length</strong> (constant time on BEAM; linear on JS because it has to encode).</p>
<pre><code class="language-gleam">import gleam/string

pub fn main() {
  echo string.is_empty("")       // True
  echo string.length("Gleam")    // 5
  echo string.length("ß↑e̊")      // 3 (graphemes)
  echo string.byte_size("Gleam") // 5
  echo string.byte_size("ß↑e̊")   // 8 (bytes)
}
</code></pre>
<h3 id="reverse"><a class="header" href="#reverse">Reverse</a></h3>
<p><code>string.reverse</code> flips by <strong>graphemes</strong>, not bytes or code points, so diacritics, emoji sequences, and composed characters stay intact:</p>
<pre><code class="language-gleam">string.reverse("stressed") // "desserts"
</code></pre>
<h3 id="replace-all-occurrences"><a class="header" href="#replace-all-occurrences">Replace (all occurrences)</a></h3>
<p><code>string.replace</code> swaps <strong>all</strong> non-overlapping matches of a substring. It's grapheme-safe and doesn't interpret patterns - just literal substring replacement - so you don't have to worry about regex semantics here. Use it for path munging, simple templating, or normalizing separators:</p>
<pre><code class="language-gleam">string.replace(in: "www.example.com", each: ".", with: "-")
// "www-example-com"
</code></pre>
<h3 id="case-conversion"><a class="header" href="#case-conversion">Case conversion</a></h3>
<p><code>lowercase</code> and <code>uppercase</code> are Unicode-aware and rely on target primitives under the hood (BEAM/JS). That means locale-agnostic rules (e.g., Turkish dotted/dotless "i" special cases are not locale-sensitive). Use these for case-folding before comparisons or when normalizing tags.</p>
<pre><code class="language-gleam">string.lowercase("X-FILES") // "x-files"
string.uppercase("skinner") // "SKINNER"
</code></pre>
<h3 id="ordering--comparison"><a class="header" href="#ordering--comparison">Ordering &amp; comparison</a></h3>
<p><code>string.compare(a, b)</code> is <strong>lexicographic over graphemes</strong>, returning <code>order.Lt</code>, <code>Eq</code>, or <code>Gt</code>:</p>
<pre><code class="language-gleam">string.compare("Anthony", "Anthony") // order.Eq
string.compare("A", "B")             // order.Lt
</code></pre>
<h3 id="substrings--slicing"><a class="header" href="#substrings--slicing">Substrings &amp; slicing</a></h3>
<p><code>slice</code> takes a starting grapheme index and a length (also in graphemes). Negative <code>at_index</code> counts from the end. Out-of-range indices are safe and yield <code>""</code>, which is great for defensive string handling:</p>
<pre><code class="language-gleam">string.slice(from: "gleam", at_index: 1, length: 2)  // "le"
string.slice(from: "gleam", at_index: -2, length: 2) // "am"
</code></pre>
<h3 id="cropping--dropping"><a class="header" href="#cropping--dropping">Cropping &amp; dropping</a></h3>
<p><code>crop(from, before)</code> finds the first occurrence of <code>before</code> and returns the remainder, useful for stripping prefixes without worrying about indices.</p>
<p><code>drop_start</code>/<code>drop_end</code> remove a fixed <strong>grapheme</strong> count from the start/end, which makes them predictable with multicodepoint characters:</p>
<pre><code class="language-gleam">string.crop(from: "The Lone Gunmen", before: "Lone") // "Lone Gunmen"
string.drop_start(from: "  hats", up_to: 2)          // "hats"
string.drop_end(from: "hats  ", up_to: 2)            // "hats"
</code></pre>
<h3 id="contains--prefix--suffix"><a class="header" href="#contains--prefix--suffix">Contains / prefix / suffix</a></h3>
<p><code>contains</code>, <code>starts_with</code>, and <code>ends_with</code> check literal substrings. They're case-sensitive and don't handle locale collation, so normalize with <code>lowercase</code> if you want case-insensitive logic:</p>
<pre><code class="language-gleam">string.contains(does: "theory", contain: "ory") // True
string.starts_with("theory", "the")             // True
string.ends_with("theory", "ory")               // True
</code></pre>
<h3 id="splitting"><a class="header" href="#splitting">Splitting</a></h3>
<p><code>split</code> returns <strong>all</strong> pieces, including a trailing empty string if the input ends with the separator - handy for filesystem-like paths where the trailing slash is meaningful.</p>
<p><code>split_once</code> stops after the first separator and returns <code>Ok(#(left, right))</code>, or <code>Error(Nil)</code> if missing - perfect for "key:value" style parsing:</p>
<pre><code class="language-gleam">string.split("home/gleam/desktop/", on: "/")
// ["home","gleam","desktop",""]

string.split_once("home/gleam/desktop/", on: "/")
// Ok(#("home", "gleam/desktop/"))
</code></pre>
<h3 id="joining--building"><a class="header" href="#joining--building">Joining &amp; building</a></h3>
<p><code>append</code>, <code>concat</code>, and <code>join</code> <strong>copy</strong> data and are linear in the total output size - great for one-off joins:</p>
<pre><code class="language-gleam">string.append(to: "butter", suffix: "fly")  // "butterfly"
string.concat(["never", "the", "less"])       // "nevertheless"
string.join(["home", "evan", "Desktop"], with: "/") // "home/evan/Desktop"
</code></pre>
<h3 id="repeating--padding"><a class="header" href="#repeating--padding">Repeating &amp; padding</a></h3>
<p><code>repeat</code> is linear in the final size and won't split graphemes.</p>
<p><code>pad_start</code>/<code>pad_end</code> pad in <strong>graphemes</strong>, so a multi-codepoint pad string counts as one grapheme per repeat, matching user expectations for alignment:</p>
<pre><code class="language-gleam">string.repeat("ha", times: 3)        // "hahaha"
string.pad_start("121", to: 5, with: ".") // "..121"
string.pad_end("123", to: 5, with: ".")   // "123.."
</code></pre>
<h3 id="trimming"><a class="header" href="#trimming">Trimming</a></h3>
<p><code>trim</code>, <code>trim_start</code>, and <code>trim_end</code> remove Unicode whitespace per the standard definition (not just ASCII spaces):</p>
<pre><code class="language-gleam">string.trim("  hats  \n")       // "hats"
string.trim_start("  hats  \n") // "hats  \n"
string.trim_end("  hats  \n")   // "  hats"
</code></pre>
<h2 id="working-at-grapheme--code-point-level"><a class="header" href="#working-at-grapheme--code-point-level">Working at grapheme / code point level</a></h2>
<h3 id="pop--iterate-graphemes"><a class="header" href="#pop--iterate-graphemes">Pop &amp; iterate graphemes</a></h3>
<p><code>pop_grapheme</code> returns the first grapheme and the rest - a clean, Unicode-safe way to peel characters from the front.</p>
<p><code>to_graphemes</code> gives you a list of grapheme clusters for iteration, cursor logic, or UI navigation.</p>
<pre><code class="language-gleam">string.pop_grapheme("gleam") // Ok(#("g", "leam"))
string.to_graphemes("abc")   // ["a", "b", "c"]
</code></pre>
<h3 id="code-points-unicode-scalars"><a class="header" href="#code-points-unicode-scalars">Code points (Unicode scalars)</a></h3>
<p>These APIs expose raw <strong>Unicode scalar values</strong> (code points), which is useful for serialization, custom parsing, or implementing algorithms that work below the grapheme layer (e.g., normalization, filters):</p>
<pre><code class="language-gleam">let cps = string.to_utf_codepoints("🏳️‍🌈")
// [UtfCodepoint(127987), 65039, 8205, 127752]

string.from_utf_codepoints(cps) // "🏳️‍🌈"
</code></pre>
<p>Creating/inspecting scalars:</p>
<pre><code class="language-gleam">let assert Ok(cp) = string.utf_codepoint(97)         // 'a'
string.utf_codepoint_to_int(cp)                      // 97
</code></pre>
<h3 id="firstlast-capitalisation-options"><a class="header" href="#firstlast-capitalisation-options">First/last, capitalisation, options</a></h3>
<p><code>first</code>/<code>last</code> return the first/last <strong>grapheme</strong> as an <code>Ok(...)</code> or an <code>Error(Nil)</code> for empty strings.</p>
<p><code>capitalise</code> uppercases the first grapheme and lowercases the rest - handy for display names, but note it's not locale-aware title-casing.</p>
<p><code>to_option</code> converts <code>""</code> to <code>None</code> and non-empty strings to <code>Some</code>, which models "maybe present text" more cleanly than sentinel empty strings.</p>
<pre><code class="language-gleam">string.first("icecream")     // Ok("i")
string.last("icecream")      // Ok("m")
string.capitalise("mamouna") // "Mamouna"
string.to_option("")         // None
string.to_option("hats")     // Some("hats")
</code></pre>
<h3 id="further-reading"><a class="header" href="#further-reading">Further reading</a></h3>
<ul>
<li><strong>Erlang Unicode usage / <code>unicode</code> module</strong>  -  background for BEAM target and UTF-8 binaries. (<a href="https://www.erlang.org/doc/apps/stdlib/unicode_usage.html" title="Using Unicode in Erlang  -  stdlib v7.0.2">Erlang.org</a>)</li>
<li><strong>Unicode UAX #29</strong>  -  grapheme/word/sentence boundaries (what "grapheme-aware" means). (<a href="https://unicode.org/reports/tr29/" title="UAX #29: Unicode Text Segmentation">Unicode</a>)</li>
<li><strong>MDN: JavaScript Strings</strong>  -  UTF-16 code units and <code>.length</code> behavior on the JS target. (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length" title="String: length - JavaScript | MDN - Mozilla">MDN Web Docs</a>)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="lists"><a class="header" href="#lists">Lists</a></h2>
<p>A <strong>list</strong> is an ordered collection of values. Lists are <strong>generic</strong> - their type records the element type: <code>List(Int)</code>, <code>List(String)</code>, etc.</p>
<p>Under the hood they're <strong>immutable singly-linked</strong> lists. That makes adding or removing at the <strong>front</strong> O(1) and anything that touches the <strong>end</strong> O(n).</p>
<p>So in Gleam you usually <strong>build from the front</strong> and avoid random indexing. These rules are the same on both Erlang/BEAM and JS targets; you use <code>gleam/list</code> for all the usual suspects like <code>map</code>, <code>filter</code>, <code>fold</code>, and friends.</p>
<h3 id="literal-syntax"><a class="header" href="#literal-syntax">Literal syntax</a></h3>
<p>Use square brackets. Empty is <code>[]</code>. Elements are homogeneous by type parameter:</p>
<pre><code class="language-gleam">let empty = []
let nums  = [1, 2, 3]
</code></pre>
<h3 id="prepend-constant-time"><a class="header" href="#prepend-constant-time">Prepend (constant time)</a></h3>
<p>Prepending doesn't copy the whole list, so it's the idiomatic way to build sequences efficiently:</p>
<pre><code class="language-gleam">let tail = [2, 3, 4]
let all  = [1, ..tail]     // -&gt; [1, 2, 3, 4]
</code></pre>
<p>That spread syntax is specific to <strong>prefixing</strong>. It's not a general "concatenate two lists" shortcut. The language even warns if you accidentally try to use it as concat.</p>
<h2 id="pattern-matching--deconstruction"><a class="header" href="#pattern-matching--deconstruction">Pattern matching &amp; deconstruction</a></h2>
<p>You can destructure lists right in a <code>case</code>. It's a clean way to branch on empty vs non-empty and bind the head and tail:</p>
<pre><code class="language-gleam">case nums {
  [] -&gt; "empty"
  [first] -&gt; "one: " &lt;&gt; int.to_string(first)
  [head, ..rest] -&gt; "head " &lt;&gt; int.to_string(head)
}
</code></pre>
<p><code>[]</code> matches empty, <code>[x]</code> matches single-element, and <code>[h, ..t]</code> peels one off the front.</p>
<h2 id="everyday-operators--utilities"><a class="header" href="#everyday-operators--utilities">Everyday operators &amp; utilities</a></h2>
<p>All functions are <strong>pure</strong> and return new lists. The important cost model: anything that must walk the list is <strong>linear</strong>; operations that only touch the head are <strong>constant time</strong>.</p>
<h3 id="length-emptiness-membership"><a class="header" href="#length-emptiness-membership">Length, emptiness, membership</a></h3>
<pre><code class="language-gleam">import gleam/list

pub fn main() {
  echo list.length([1, 2, 3])   // 3
  echo list.is_empty([])        // True
  echo list.contains([1, 0], 0) // True
}
</code></pre>
<p><code>length</code> and <code>contains</code> traverse the list, so they're O(n). Use them when you need them, but don't call them in tight loops if you can carry the info through folds instead.</p>
<h3 id="head--tail"><a class="header" href="#head--tail">Head &amp; tail</a></h3>
<pre><code class="language-gleam">list.first([1, 2])  // Ok(1)
list.rest([1, 2])   // Ok([2])
</code></pre>
<p>These do not copy. They're constant time and the safest way to peek or step through a list one element at a time.</p>
<h3 id="map--filter--fold"><a class="header" href="#map--filter--fold">Map / Filter / Fold</a></h3>
<pre><code class="language-gleam">list.map([2, 4, 6], fn(x) { x * 2 })     // [4, 8, 12]
list.filter([2, 4, 6, 1], fn(x) { x &gt; 2 }) // [4, 6]
list.fold([1, 2, 3], 0, fn(acc, x) { acc + x }) // 6
</code></pre>
<p>These are your <strong>loops</strong>. Prefer them over manual recursion for clarity.</p>
<h3 id="find--predicates"><a class="header" href="#find--predicates">Find &amp; predicates</a></h3>
<pre><code class="language-gleam">list.find([1, 2, 3], fn(x) { x &gt; 2 }) // Ok(3)
list.any([3, 4], fn(x) { x &gt; 3 })     // True
list.all([4, 5], fn(x) { x &gt; 3 })     // True
</code></pre>
<p><code>any</code>/<code>all</code> <strong>short-circuit</strong>, which is handy for guards and validations without scanning the whole list unnecessarily.</p>
<h3 id="zipping--unzipping"><a class="header" href="#zipping--unzipping">Zipping &amp; unzipping</a></h3>
<pre><code class="language-gleam">list.zip([1, 2], ["a", "b"])           // [#(1, "a"), #(2, "b")]
list.unzip([#(1, 2), #(3, 4)])         // #([1, 3], [2, 4])
</code></pre>
<p>If you need equal lengths guaranteed, use <code>strict_zip</code> which returns <code>Error(Nil)</code> on mismatch. Great for pairing coordinates, ids to names, etc.</p>
<h3 id="append-flatten-flat_map"><a class="header" href="#append-flatten-flat_map">Append, flatten, flat_map</a></h3>
<pre><code class="language-gleam">list.append([1, 2], [3])                     // [1, 2, 3]
list.flatten([[1], [2, 3], []])              // [1, 2, 3]
list.flat_map([2, 4], fn(x) { [x, x + 1] })  // [2, 3, 4, 5]
</code></pre>
<p><code>append</code> must <strong>copy the first list</strong>, so it's O(n).</p>
<p>In hot paths, build by <strong>prepending inside a fold</strong> and finish with a single <code>reverse</code>. That keeps each step O(1) and has one linear pass at the end.</p>
<h3 id="take--drop-safe-slicing"><a class="header" href="#take--drop-safe-slicing">Take &amp; drop (safe slicing)</a></h3>
<pre><code class="language-gleam">list.take([1, 2, 3, 4], 2) // [1, 2]
list.drop([1, 2, 3, 4], 2) // [3, 4]
</code></pre>
<p>Both are linear. <code>drop</code> doesn't copy nodes it skips, which makes it an efficient way to "advance" a cursor in streaming code.</p>
<h3 id="unique-sort"><a class="header" href="#unique-sort">Unique, sort</a></h3>
<pre><code class="language-gleam">list.unique([1, 1, 4, 7, 3, 3, 4]) // [1, 4, 7, 3]
list.sort([4, 3, 6, 5, 4, 1, 2], by: int.compare) // [1, 2, 3, 4, 4, 5, 6]
</code></pre>
<p><code>unique</code> runs in <strong>log-linear</strong> time; it preserves the <strong>first occurrence</strong> order.</p>
<p><code>sort</code> takes a comparator and returns a new sorted list.</p>
<h3 id="windows-chunks-partitions"><a class="header" href="#windows-chunks-partitions">Windows, chunks, partitions</a></h3>
<pre><code class="language-gleam">list.window([1, 2, 3, 4, 5], by: 3)            // [[1,2,3],[2,3,4],[3,4,5]]
list.sized_chunk([1, 2, 3, 4, 5, 6], into: 2)  // [[1,2],[3,4],[5,6]]
list.partition([1, 2, 3, 4, 5], int.is_odd)    // #([1,3,5], [2,4])
</code></pre>
<p>Use sliding <code>window</code> for rolling metrics, <code>sized_chunk</code> for batching, and <code>partition</code> to split by a predicate in one pass.</p>
<blockquote>
<p><strong>Note</strong>: <code>transpose</code> isn't tail-recursive on JS and can blow the stack with huge lists.</p>
</blockquote>
<h3 id="ranges--repetition"><a class="header" href="#ranges--repetition">Ranges &amp; repetition</a></h3>
<pre><code class="language-gleam">list.range(0, 5)        // [0, 1, 2, 3, 4, 5]
list.repeat("a", 3)     // ["a", "a", "a"]
</code></pre>
<p>Great for generating test data, producing index sequences, or simple stubs.</p>
<h2 id="when-not-to-use-a-list"><a class="header" href="#when-not-to-use-a-list">When not to use a list</a></h2>
<p>If you need <strong>random access</strong> or frequent updates in the <strong>middle/end</strong>, a singly-linked list is the wrong tool.</p>
<p>Consider <code>gleam/dict</code> for keyed lookups, or restructure the algorithm around streaming with folds. Index-based algorithms are rare in Gleam because lists are linked. If you must, <code>list.at</code> exists but returns a <code>Result</code> and is still O(n).</p>
<h2 id="tuples"><a class="header" href="#tuples">Tuples</a></h2>
<p>A <strong>tuple</strong> groups a fixed number of values, possibly of <strong>different types</strong>. They're perfect for small, ad-hoc groupings or multi-value returns, like <code>#(status_code, body)</code> or <code>#(x, y)</code>. If the group has domain meaning, prefer a custom type or record to make the fields self-describing. Tuples are immutable and have a fixed arity.</p>
<h3 id="literal-syntax-1"><a class="header" href="#literal-syntax-1">Literal syntax</a></h3>
<pre><code class="language-gleam">let pair = #(200, "OK")
let triple = #("x", 10, True)
</code></pre>
<p>Arity is part of the type. For example, <code>#(Int, String)</code> is a different type from <code>#(Int, String, Bool)</code>.</p>
<h3 id="positional-accessors-no-pattern-match-needed"><a class="header" href="#positional-accessors-no-pattern-match-needed">Positional accessors (no pattern match needed)</a></h3>
<pre><code class="language-gleam">pair.0   // 200
pair.1   // "OK"
triple.2 // True
</code></pre>
<p>These <strong>zero-based</strong> accessors are convenient for quick reads and are part of the official tour. They're great when you only need one field and don't want a full <code>case</code>.</p>
<h3 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern matching</a></h3>
<pre><code class="language-gleam">case triple {
  #(name, count, active) -&gt; name &lt;&gt; " " &lt;&gt; int.to_string(count)
}
</code></pre>
<p>Pattern matching shines when you want to destructure and name everything at once. If you find yourself passing tuples around widely, consider a custom type for readability.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="assignments"><a class="header" href="#assignments">Assignments</a></h2>
<p>In Gleam you bind values with <code>let</code>. Names use <code>snake_case</code>, bindings are <strong>immutable</strong>, and you can <strong>re-bind</strong> a name later to a new value (the old value doesn’t change; you just shadow the name).</p>
<pre><code class="language-gleam">import gleam/io

pub fn main() {
  let x = "Original"
  io.println(x)

  // Copy the value
  let y = x
  io.println(y)

  // Shadow x with a new value
  let x = "New"
  io.println(x)

  // y still points to the original value
  io.println(y)
}
</code></pre>
<p>If you create a variable and never use it, the compiler warns you. Prefix it with an underscore to show that’s intentional.</p>
<pre><code class="language-gleam">pub fn main() {
  // Intentional: silence the unused warning
  let _score = 1000
}
</code></pre>
<p>You can add type annotations to <code>let</code> bindings. They help readers but don’t change how type checking works (other than catching mismatches).</p>
<pre><code class="language-gleam">pub fn main() {
  let _name: String = "Gleam"
  let _is_cool: Bool = True
  let _version: Int = 1
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pattern-matching-1"><a class="header" href="#pattern-matching-1">Pattern matching</a></h2>
<p>Gleam lets you <strong>pattern match</strong> both when assigning and in <code>case</code> expressions.</p>
<h3 id="let-clause"><a class="header" href="#let-clause">Let clause</a></h3>
<p>With plain <code>let</code>, your pattern has to be <strong>total</strong> for the value’s shape - i.e., it must always match.</p>
<pre><code class="language-gleam">pub fn main() {
  // Tuple destructuring: always matches a 2-tuple
  let point = #(3, 4)
  let #(x, y) = point

  io.println(int.to_string(x + y))
}
</code></pre>
<h3 id="case-expression"><a class="header" href="#case-expression">Case expression</a></h3>
<p><code>case</code> lets you handle multiple shapes safely. You can match strings using concatenation syntax:</p>
<pre><code class="language-gleam">import gleam/io

pub fn main() {
  io.println(get_name("Hello, Joe"))
  io.println(get_name("Hello, Mike"))
  io.println(get_name("System still working?"))
}

fn get_name(x: String) -&gt; String {
  case x {
    "Hello, " &lt;&gt; name -&gt; name
    _ -&gt; "Unknown"
  }
}
</code></pre>
<p>When working with lists you can match on length and contents. Use <code>..</code> to capture "the rest" of the elements.</p>
<pre><code class="language-gleam">import gleam/int
import gleam/list
import gleam/io

pub fn main() {
  let xs = list.repeat(int.random(5), times: int.random(3))
  io.println(list.to_string(xs, int.to_string))

  let result = case xs {
    [] -&gt; "Empty list"
    [1] -&gt; "List of just 1"
    [4, ..] -&gt; "List starting with 4"
    [_, _] -&gt; "List of 2 elements"
    _ -&gt; "Some other list"
  }

  io.println(result)
}
</code></pre>
<h3 id="let-assert"><a class="header" href="#let-assert"><code>let assert</code></a></h3>
<p>Sometimes you <em>know</em> a value has a certain shape and want to crash immediately if it doesn’t. <code>let assert</code> is like <code>let</code>, but it allows <strong>partial</strong> patterns. If the pattern doesn’t match, the program panics. You can attach a custom message with <code>as</code>.</p>
<pre><code class="language-gleam">pub fn main() {
  let a = unsafely_get_first_element([123])
  io.println(int.to_string(a))

  // This will panic at runtime with our custom message:
  let b = unsafely_get_first_element([])
  io.println(int.to_string(b))
}

pub fn unsafely_get_first_element(items: List(a)) -&gt; a {
  // Partial pattern: will panic on []
  let assert [first, ..] = items as "List should not be empty"
  first
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>In Gleam, the <code>fn</code> keyword defines a function. Like blocks, the body is a series of expressions evaluated top-to-bottom, and <strong>the last expression's value is returned</strong> - there's no <code>return</code> keyword.</p>
<p>Functions are <strong>private by default</strong>. Add <code>pub</code> to make them usable from other modules. Type annotations for parameters and return types are optional but encouraged for clarity.</p>
<pre><code class="language-gleam">pub fn main() {
  echo double(10)
}

fn double(a: Int) -&gt; Int {       // private
  multiply(a, 2)
}

fn multiply(a: Int, b: Int) -&gt; Int {
  a * b
}
</code></pre>
<h3 id="higher-order-functions"><a class="header" href="#higher-order-functions">Higher-order functions</a></h3>
<p>Functions are values. You can <strong>pass them around</strong>, store them in variables, and return them - this is the basis for map/filter/fold and composition patterns. The parameter type for a function value is written with <code>fn(...) -&gt; ...</code>.</p>
<pre><code class="language-gleam">pub fn main() {
  echo twice(1, add_one)    // pass a function
  let my_function = add_one // store a function
  echo my_function(100)
}

fn twice(argument: Int, passed_function: fn(Int) -&gt; Int) -&gt; Int {
  passed_function(passed_function(argument))
}

fn add_one(argument: Int) -&gt; Int {
  argument + 1
}
</code></pre>
<h3 id="anonymous-functions"><a class="header" href="#anonymous-functions">Anonymous functions</a></h3>
<p>Anonymous functions use <code>fn(...) { ... }</code>. They're interchangeable with named functions and <strong>capture variables</strong> in scope (closures), which is handy for customizing behavior with local data.</p>
<pre><code class="language-gleam">pub fn main() {
  let add_one = fn(a) { a + 1 }
  echo twice(1, add_one)

  echo twice(1, fn(a) { a * 2 })  // inline

  let secret_number = 42
  let secret = fn() { secret_number } // captures 42
  echo secret()
}

fn twice(argument: Int, my_function: fn(Int) -&gt; Int) -&gt; Int {
  my_function(my_function(argument))
}
</code></pre>
<p>Closures let you "bake in" environment values without threading them through every call.</p>
<h3 id="function-captures"><a class="header" href="#function-captures">Function captures</a></h3>
<p>For the common "wrap a function and pass one argument through" case, use <strong>function capture</strong>: replace the flowing argument with <code>_</code>. It's shorthand for <code>fn(x) { some_fun(..., x, ...) }</code>.</p>
<pre><code class="language-gleam">pub fn main() {
  // These are equivalent
  let add_one_v1 = fn(x) { add(1, x) }
  let add_one_v2 = add(1, _)

  echo add_one_v1(10)
  echo add_one_v2(10)
}

fn add(a: Int, b: Int) -&gt; Int {
  a + b
}
</code></pre>
<p>This reads nicely in pipelines or when reordering parameters.</p>
<h3 id="generic-functions"><a class="header" href="#generic-functions">Generic functions</a></h3>
<p>When your logic doesn't care about a concrete type, use a <strong>type variable</strong> (lowercase) to make a function generic. The compiler instantiates it with a specific type at each call site. This is stricter than "any" - it must be <strong>the same</strong> type throughout that call.</p>
<pre><code class="language-gleam">pub fn main() {
  let add_one = fn(x) { x + 1 }
  let exclaim = fn(x) { x &lt;&gt; "!" }

  // twice(10, exclaim)          // invalid: types conflict

  echo twice(10, add_one)        // value = Int here
  echo twice("Hello", exclaim)   // value = String here
}

fn twice(argument: value, my_function: fn(value) -&gt; value) -&gt; value {
  my_function(my_function(argument))
}
</code></pre>
<p>Result: reusable functions with strong static guarantees - no runtime type checks needed.</p>
<h3 id="pipelines-1"><a class="header" href="#pipelines-1">Pipelines</a></h3>
<p>The <strong>pipe operator</strong> <code>|&gt;</code> passes the value on the left into the function on the right, letting you read transformations <strong>top-to-bottom</strong>. It tries to place the piped value as the <strong>first argument</strong>; if that doesn't fit, it treats the right side as a function that returns a function (so <code>b(1,2)(a)</code>). Capture <code>_</code> helps target a different parameter position.</p>
<pre><code class="language-gleam">import gleam/io
import gleam/string

pub fn main() {
  // Without the pipe operator
  io.println(string.drop_start(string.drop_end("Hello, Joe!", 1), 7))

  // With the pipe operator
  "Hello, Mike!"
  |&gt; string.drop_end(1)
  |&gt; string.drop_start(7)
  |&gt; io.println

  // Reordering with a capture
  "1"
  |&gt; string.append("2")
  |&gt; string.append("3", _)
  |&gt; io.println
}
</code></pre>
<p>Pipes are the idiomatic way to <strong>compose</strong> in Gleam - most stdlib functions put the "subject" first to make piping natural.</p>
<h3 id="labelled-arguments"><a class="header" href="#labelled-arguments">Labelled arguments</a></h3>
<p>Give arguments <strong>labels</strong> to self-document calls and avoid "what does the second <code>Int</code> mean?" moments. Labels are written <strong>before</strong> the parameter name in the definition; at call sites you can supply them in any order. Unlabelled args must come first. No runtime cost.</p>
<pre><code class="language-gleam">pub fn main() {
  echo calculate(1, add: 2, multiply: 3)
  echo calculate(1, multiply: 3, add: 2) // order doesn't matter
  echo calculate(1, 2, 3)                // labels optional when calling
}

fn calculate(value: Int, add addend: Int, multiply multiplier: Int) {
  value * multiplier + addend
}
</code></pre>
<p>Labels shine in APIs with multiple same-typed parameters.</p>
<h3 id="label-shorthand"><a class="header" href="#label-shorthand">Label shorthand</a></h3>
<p>If local variable names match the labels, you can <strong>omit</strong> the names at the call site - nice for records and functions with many labelled args. This shorthand is part of the language and widely used in examples and blog posts.</p>
<pre><code class="language-gleam">pub fn main() {
  let quantity = 5.0
  let unit_price = 10.0
  let discount = 0.2

  // Regular label syntax
  echo calculate_total_cost(
    quantity: quantity,
    unit_price: unit_price,
    discount: discount,
  )

  // Shorthand (names match labels)
  echo calculate_total_cost(quantity:, unit_price:, discount:)
}

fn calculate_total_cost(
  quantity quantity: Float,
  unit_price price: Float,
  discount discount: Float,
) -&gt; Float {
  let subtotal = quantity *. price
  let discount = subtotal *. discount
  subtotal -. discount
}
</code></pre>
<p>Shorthand keeps the call sites tidy without sacrificing readability.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="result"><a class="header" href="#result">Result</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expression-blocks"><a class="header" href="#expression-blocks">Expression blocks</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panic-and-assert"><a class="header" href="#panic-and-assert">Panic and assert</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-custom-types"><a class="header" href="#creating-custom-types">Creating custom types</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules-and-imports"><a class="header" href="#modules-and-imports">Modules and imports</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-gleam"><a class="header" href="#advanced-gleam">Advanced Gleam</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo"><a class="header" href="#todo">Todo</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bit-strings"><a class="header" href="#bit-strings">Bit strings</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="escape-sequences"><a class="header" href="#escape-sequences">escape sequences</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tail-call-optimisation"><a class="header" href="#tail-call-optimisation">Tail call optimisation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="phantom-types"><a class="header" href="#phantom-types">Phantom types</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="labelled-arguments-1"><a class="header" href="#labelled-arguments-1">Labelled arguments</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="labelled-fields"><a class="header" href="#labelled-fields">Labelled fields</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dict"><a class="header" href="#dict">Dict</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pairs"><a class="header" href="#pairs">Pairs</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sets"><a class="header" href="#sets">Sets</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="option"><a class="header" href="#option">Option</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="order"><a class="header" href="#order">Order</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterator"><a class="header" href="#iterator">Iterator</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="opaque-types"><a class="header" href="#opaque-types">Opaque types</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="queue"><a class="header" href="#queue">Queue</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="erlang-and-javascript-interop"><a class="header" href="#erlang-and-javascript-interop">Erlang and Javascript interop</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytes-and-string-builders"><a class="header" href="#bytes-and-string-builders">Bytes and string builders</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="base64"><a class="header" href="#base64">Base64</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="regex"><a class="header" href="#regex">Regex</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uri"><a class="header" href="#uri">URI</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecosystem"><a class="header" href="#ecosystem">Ecosystem</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-custom-packages"><a class="header" href="#installing-custom-packages">Installing custom packages</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-and-publishing-a-package"><a class="header" href="#creating-and-publishing-a-package">Creating and publishing a package</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gleam-docker-images"><a class="header" href="#gleam-docker-images">Gleam docker images</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simplifile-package"><a class="header" href="#simplifile-package">Simplifile package</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filepath-filepath"><a class="header" href="#filepath-filepath">Filepath: filepath</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ranges-ranger"><a class="header" href="#ranges-ranger">Ranges: ranger</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="datetime-birl"><a class="header" href="#datetime-birl">Datetime: birl</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ad-hoc-error-type-snag"><a class="header" href="#ad-hoc-error-type-snag">Ad-hoc error type: snag</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json-gleam_json"><a class="header" href="#json-gleam_json">Json: gleam_json</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gleam_crypto"><a class="header" href="#gleam_crypto">gleam_crypto</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="syntax.js"></script>
        <script src="highlight.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
