<!DOCTYPE HTML>
<html lang="en" class="latte sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Gleam programming language</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-3865ffda.css">
        <link rel="stylesheet" href="css/general-5b48641a.css">
        <link rel="stylesheet" href="css/chrome-c0e702bf.css">
        <link rel="stylesheet" href="css/print-ad67d350.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./theme/catppuccin.css">
        <link rel="stylesheet" href="./theme/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "latte";
            const default_dark_theme = "mocha";
            window.path_to_searchindex_js = "searchindex-aacf2f74.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-d2d9e2d5.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('latte')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="latte">Latte</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="frappe">Frapp√©</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="macchiato">Macchiato</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mocha">Mocha</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Gleam programming language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/abs0luty/gleam-tutorial" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fab-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a href="#introduction" class="header">Introduction</a></h1>
<h2 id="what-is-gleam"><a class="header" href="#what-is-gleam">What is Gleam?</a></h2>
<p><strong>Gleam</strong> is a modern, friendly programming language for building type-safe and scalable systems. It compiles to <a href="http://www.erlang.org/">Erlang</a> and JavaScript, and integrates seamlessly with other BEAM languages like Erlang, Elixir, and LFE.</p>
<p>A simple Gleam program looks like this:</p>
<pre><code class="language-gleam">import gleam/io

pub fn main() {
  io.println("hello, world!")
}
</code></pre>
<p>Gleam combines the guarantees of a strong type system, the expressiveness of functional programming, and the reliability of the highly concurrent Erlang runtime.</p>
<h2 id="reliability-and-scalability"><a class="header" href="#reliability-and-scalability">Reliability and scalability</a></h2>
<p>Running on the Erlang virtual machine - the same platform behind large-scale systems such as WhatsApp - Gleam is built for production workloads of any size.</p>
<p>The BEAM runtime enables:</p>
<ul>
<li>Multi-core, actor-based concurrency with millions of lightweight processes.</li>
<li>Immutable data structures for safe parallelism.</li>
<li>A concurrent garbage collector that never pauses the entire system.</li>
</ul>
<pre><code class="language-gleam">fn spawn_task(i) {
  task.async(fn() {
    let n = int.to_string(i)
    io.println("Hello from " &lt;&gt; n)
  })
}

pub fn main() {
  list.range(0, 200_000)
  |&gt; list.map(spawn_task)
  |&gt; list.each(task.await_forever)
}
</code></pre>
<h2 id="use-syntax"><a class="header" href="#use-syntax">Use syntax</a></h2>
<p>Gleam‚Äôs <code>use</code> syntax lets you write callback-based APIs in a flat, top-to-bottom style, killing the ‚Äúpyramid of doom‚Äù.</p>
<p>It‚Äôs pure syntax sugar that rewrites the rest of the block into an anonymous function passed to the callee, so you keep the same semantics (no new runtime magic) but lose the nesting - making control flow and error cases much easier to read and maintain:</p>
<pre><code class="language-gleam">pub fn with_use() -&gt; Result(String, Nil) {
  use username &lt;- result.try(get_username())
  use password &lt;- result.try(get_password())
  use greeting &lt;- result.map(log_in(username, password))
  greeting &lt;&gt; ", " &lt;&gt; username
}
</code></pre>
<p>Without <code>use</code>, the same logic requires nested anonymous functions:</p>
<pre><code class="language-gleam">pub fn without_use() -&gt; Result(String, Nil) {
  result.try(get_username(), fn(username) {
    result.try(get_password(), fn(password) {
      result.map(log_in(username, password), fn(greeting) {
        greeting &lt;&gt; ", " &lt;&gt; username
      })
    })
  })
}
</code></pre>
<h2 id="built-in-tools"><a class="header" href="#built-in-tools">Built-in tools</a></h2>
<p>Gleam ships with everything you need: a compiler, build tool, formatter, package manager, and editor integrations. Starting a new project is as simple as:</p>
<pre><code>gleam new my_project
</code></pre>
<p>The ecosystem includes thousands of packages from Gleam, Erlang, and Elixir. For example:</p>
<pre><code>‚ûú gleam add gleam_json
      Added gleam_json v0.5.0
‚ûú gleam test
   Running app_test.main
.
1 tests, 0 failures
</code></pre>
<h2 id="developer-friendly"><a class="header" href="#developer-friendly">Developer-friendly</a></h2>
<p>Gleam avoids common pitfalls like null values and exceptions. Its type system and error messages are designed to be practical and approachable:</p>
<pre><code>error: Unknown record field

  ‚îå‚îÄ ./src/app.gleam:8:16
  ‚îÇ
8 ‚îÇ user.alias
  ‚îÇ     ^^^^^^ Did you mean `name`?

The value being accessed has this type:
    User

It has these fields:
    .name
</code></pre>
<h2 id="interoperability"><a class="header" href="#interoperability">Interoperability</a></h2>
<p>Gleam works smoothly with other BEAM languages, giving you access to a vast ecosystem of libraries. It can also compile to JavaScript, complete with TypeScript definitions for safe interoperability.</p>
<pre><code class="language-gleam">@external(erlang, "Elixir.HPAX", "new")
pub fn new(size: Int) -&gt; Table

pub fn register_event_handler() {
  let el = document.query_selector("a")
  element.add_event_listener(el, fn() {
    io.println("Clicked!")
  })
}
</code></pre>
<h2 id="learn-more"><a class="header" href="#learn-more">Learn more</a></h2>
<ul>
<li><a href="https://gleam.run/book/tour/">Language tour</a></li>
<li><a href="https://gleam.run">Official website</a></li>
<li><a href="https://discord.com/invite/Fm8Pwmy">Discord server</a></li>
<li><a href="https://github.com/gleam-lang">Github</a></li>
<li><a href="https://gleam.run/documentation#cheatsheets">Cheat sheets for:</a>
<ul>
<li><a href="https://gleam.run/cheatsheets/gleam-for-elixir-users/">Elixir users</a>, <a href="https://gleam.run/cheatsheets/gleam-for-elm-users">Elm users</a>, <a href="https://gleam.run/cheatsheets/gleam-for-erlang-users">Erlang users</a></li>
<li><a href="https://gleam.run/cheatsheets/gleam-for-php-users">PHP users</a>, <a href="https://gleam.run/cheatsheets/gleam-for-python-users">Python users</a>, <a href="https://gleam.run/cheatsheets/gleam-for-rust-users">Rust users</a></li>
</ul>
</li>
<li><a href="https://github.com/gleam-lang/awesome-gleam">Awesome Gleam resource list</a></li>
<li><a href="https://hexdocs.pm/gleam_stdlib/">Standard library documentation</a></li>
<li><a href="https://packages.gleam.run/">Gleam package index</a></li>
<li><a href="https://gleam.run/writing-gleam/gleam-toml/"><code>gleam.toml</code> file reference</a></li>
<li><a href="https://gleam.run/writing-gleam/command-line-reference/">Command line reference (for <code>gleam</code> command)</a></li>
<li><a href="https://erlangforums.com/c/beam-language-forums/gleam-forum/36">Gleam‚Äôs threads on the Erlang Forums</a></li>
<li><a href="https://github.com/gleam-lang/gleam/discussions">Gleam discussions on Github</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="quick-start"><a href="#quick-start" class="header">Quick start</a></h1>
<h2 id="installing-erlang"><a class="header" href="#installing-erlang">Installing Erlang</a></h2>
<p>Since Gleam primarily compiles to Erlang (with optional JavaScript support), you‚Äôll need Erlang installed on your system first.</p>
<p><strong>On Linux and macOS:</strong></p>
<ul>
<li><strong>Homebrew (macOS):</strong> <code>brew install erlang</code></li>
<li><strong>MacPorts (macOS):</strong> <code>port install erlang</code></li>
<li><strong>Ubuntu/Debian:</strong> <code>apt-get install erlang</code></li>
<li><strong>Fedora:</strong> <code>yum install erlang</code></li>
<li><strong>Arch Linux/Manjaro:</strong> <code>pacman -S erlang</code></li>
<li><strong>FreeBSD:</strong> <code>pkg install erlang</code></li>
</ul>
<p><strong>On Windows:</strong>
Download and install Erlang using the official installers:</p>
<ul>
<li><a href="https://github.com/erlang/otp/releases/download/OTP-26.1.2/otp_win64_26.1.2.exe">64-bit</a></li>
<li><a href="https://github.com/erlang/otp/releases/download/OTP-26.1.2/otp_win32_26.1.2.exe">32-bit</a></li>
</ul>
<h2 id="installing-gleam"><a class="header" href="#installing-gleam">Installing Gleam</a></h2>
<p>The simplest way to get Gleam is from the <a href="https://github.com/gleam-lang/gleam/releases">GitHub releases page</a>.
Download the latest release for your operating system and follow the installation instructions.</p>
<h2 id="building-from-source"><a class="header" href="#building-from-source">Building from Source</a></h2>
<p>You may want to build Gleam from source if you‚Äôre contributing to the language or compiling it for WebAssembly.</p>
<ol>
<li>
<p><strong>Clone the repository:</strong></p>
<pre><code class="language-sh">git clone https://github.com/gleam-lang/gleam
cd gleam
</code></pre>
</li>
<li>
<p><strong>Install Rust:</strong>
Gleam‚Äôs compiler is written in Rust. Install it via <code>rustup</code>:</p>
<ul>
<li>
<p><strong>Linux/macOS:</strong></p>
<pre><code class="language-sh">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
</li>
<li>
<p><strong>Windows:</strong>
Download the installer from the <a href="https://forge.rust-lang.org/infra/other-installation-methods.html">Rust website</a>, run it, then use:</p>
<pre><code class="language-sh">rustup toolchain install stable
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Build the compiler:</strong></p>
<pre><code class="language-sh">cargo install --path gleam-bin 
</code></pre>
<p>This installs Gleam globally on your system.</p>
</li>
</ol>
<h2 id="building-for-webassembly"><a class="header" href="#building-for-webassembly">Building for WebAssembly</a></h2>
<p>To compile Gleam for WebAssembly, install <code>wasm-pack</code>:</p>
<ul>
<li>
<p><strong>Linux/macOS:</strong></p>
<pre><code class="language-sh">curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh
</code></pre>
</li>
<li>
<p><strong>Windows (alternative):</strong></p>
<pre><code class="language-sh">cargo install wasm-pack
</code></pre>
</li>
</ul>
<p>Then build the WebAssembly target:</p>
<pre><code class="language-sh">cd compiler-wasm
wasm-pack build --target web
</code></pre>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello world</a></h2>
<p>Let us now write our first Gleam program! <em>If you don‚Äôt have Gleam installed, it is recommended to follow instructions in the <a href="installation.html">previous section</a></em>. Run:</p>
<pre><code>gleam new hello_world
cd hello_world
</code></pre>
<p>You can now see the automatically generated Gleam project structure:</p>
<pre><code>hello_world
|_ .github/workflows
   |_ test.yml
|_ src
   |_ hello_world.gleam
|_ test
   |_ hello_world_test.gleam
|_ .gitignore
|_ gleam.toml
|_ README.md
</code></pre>
<p>The entry point is located in the <code>src/hello_world.gleam</code> file. It will probably look something like this:</p>
<pre><code class="language-gleam">import gleam/io

pub fn main() {
  io.println("Hello from hello_world!")
}
</code></pre>
<p>Let us change our program, so that it prints canonical <code>Hello, world!</code> message:</p>
<pre><code class="language-gleam">import gleam/io

pub fn main() {
  io.println("Hello, world!")
}
</code></pre>
<p>As you can see, Gleam doesn‚Äôt require semicolons. To run the program, you can use <code>gleam run</code> command:</p>
<pre><code>$ gleam run
  Compiling gleam_stdlib
  Compiling gleeunit
  Compiling hello_world
   Compiled in 1.78s
    Running hello_world.main
Hello, world!
</code></pre>
<p>By default, it transpiles our code to erlang and uses it to run our code. However, you can also use javascript using <code>--target</code> flag:</p>
<pre><code>$ gleam run --target javascript
  Compiling gleam_stdlib
  Compiling gleeunit
  Compiling hello_world
   Compiled in 1.5s
    Running hello_world.main
Hello, world!
</code></pre>
<p>You can also use specific javascript runtime using <code>--runtime</code> flag:</p>
<pre><code>$ gleam run --target javascript --runtime node
  Compiling gleam_stdlib
  Compiling gleeunit
  Compiling hello_world
   Compiled in 1.5s
    Running hello_world.main
Hello, world!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="basics"><a href="#basics" class="header">Basics</a></h1>
<h2 id="who-this-tutorial-is-for"><a class="header" href="#who-this-tutorial-is-for">Who This Tutorial Is For</a></h2>
<p>This guide is for people who already know how to code. If you‚Äôre familiar with variables, functions, types, and control flow, you‚Äôre in the right spot.</p>
<p>We won‚Äôt explain the basics of programming. Instead, we‚Äôll focus on how things work in Gleam and on the BEAM. If you‚Äôre coming from Python, JavaScript, Go, C++, or similar, you‚Äôll be fine - even if functional programming is new to you.</p>
<p>You don‚Äôt need to know FP going in. This is aimed at curious developers who want a solid intro to a functional language that runs on the BEAM. It follows the style of guides like <em>Learn You a Haskell</em>, which assume programming experience but not a background in FP.</p>
<p>Think of this as a fast-moving tour from one developer to another. Like the Go Tour or the Rust Book, it covers practical syntax and patterns instead of explaining what a loop is.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="comments-1"><a href="#comments-1" class="header">Comments</a></h1>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<p>You can add comments to your Gleam code with <code>//</code>. They help explain intent and improve readability.</p>
<p>Here‚Äôs a simple example that adds a comment above a print call:</p>
<pre><code class="language-gleam">import gleam/io

pub fn main() {
  // Show a message
  io.println("Hello world!")
}
</code></pre>
<p>For longer explanations, use <code>//</code> at the start of each line:</p>
<pre><code class="language-gleam">// This is a longer comment.
// Each line starts with //
// so the compiler treats it as a comment.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="booleans-and-numbers"><a href="#booleans-and-numbers" class="header">Booleans and numbers</a></h1>
<h2 id="booleans"><a class="header" href="#booleans">Booleans</a></h2>
<p>Gleam uses <code>True</code> and <code>False</code> as boolean values. Their type is <code>Bool</code>. You can apply logical operators like:</p>
<pre><code class="language-gleam">False &amp;&amp; False  // False
True &amp;&amp; False   // False
True &amp;&amp; True    // True

False || False  // False
True || False   // True
True || True    // True
</code></pre>
<p>Both operators short-circuit:</p>
<ul>
<li><code>False &amp;&amp; ...</code> skips the right side.</li>
<li><code>True || ...</code> skips the right side.</li>
</ul>
<pre><code class="language-gleam">import gleam/io

fn message() -&gt; Bool {
  io.println("evaluated")
  True
}

pub fn main() {
  let _ = False &amp;&amp; message()  // doesn't print anything
  let _ = True &amp;&amp; message()   // prints "evaluated"
}
</code></pre>
<h3 id="printing-booleans"><a class="header" href="#printing-booleans">Printing Booleans</a></h3>
<p>Convert a <code>Bool</code> to a <code>String</code> before printing:</p>
<pre><code class="language-gleam">import gleam/io
import gleam/bool

pub fn main() {
  io.println(bool.to_string(False))
}
</code></pre>
<p>You can also use <code>echo</code> for debugging:</p>
<pre><code class="language-gleam">pub fn main() {
  echo True
}
</code></pre>
<h3 id="negation"><a class="header" href="#negation">Negation</a></h3>
<p>Negate with <code>!</code> or <code>bool.negate</code>:</p>
<pre><code class="language-gleam">import gleam/bool

!True              // False
bool.negate(False) // True
</code></pre>
<h2 id="numbers"><a class="header" href="#numbers">Numbers</a></h2>
<p>Gleam supports two numeric types:</p>
<ul>
<li><code>Int</code> for whole numbers</li>
<li><code>Float</code> for decimal numbers</li>
</ul>
<h3 id="integers"><a class="header" href="#integers">Integers</a></h3>
<p>Integers support basic arithmetic:</p>
<pre><code class="language-gleam">1 + 2 - 3 * 4 // =&gt; -9
7 / 2         // =&gt; 3
3 % 2         // =&gt; 1
</code></pre>
<p>Division by zero returns <code>0</code>:</p>
<pre><code class="language-gleam">5 / 0 // =&gt; 0
</code></pre>
<p>Use <code>int.divide</code> to handle division safely:</p>
<pre><code class="language-gleam">import gleam/int

int.divide(5, 2) // Ok(2)
int.divide(5, 0) // Error(Nil)
</code></pre>
<p>You can write large numbers with <code>_</code>:</p>
<pre><code class="language-gleam">1_000_000
</code></pre>
<p>Gleam also supports binary, octal, and hexadecimal:</p>
<pre><code class="language-gleam">0b1010
0o755
0xFF
</code></pre>
<p>Comparison is straightforward:</p>
<pre><code class="language-gleam">1 &gt; 0   // True
2 &lt;= 2  // True
</code></pre>
<h3 id="working-with-integers"><a class="header" href="#working-with-integers">Working with Integers</a></h3>
<p>Convert to string:</p>
<pre><code class="language-gleam">import gleam/int
int.to_string(42)
</code></pre>
<p>Convert to float:</p>
<pre><code class="language-gleam">int.to_float(2)  // 2.0
</code></pre>
<p>Other helpers:</p>
<pre><code class="language-gleam">int.absolute_value(-10)   // 10
int.negate(5)             // -5
int.min(1, 3)             // 1
int.max(1, 3)             // 3
int.square_root(4)        // Ok(2.0)
int.square_root(-1)       // Error(Nil)
int.is_even(2)            // True
int.is_odd(3)             // True
</code></pre>
<p>Convert to base:</p>
<pre><code class="language-gleam">int.to_base2(5)    // "101"
int.to_base16(255) // "FF"
int.to_base_string(48, 36) // Ok("1C")
</code></pre>
<p>Invalid base values return an error:</p>
<pre><code class="language-gleam">int.to_base_string(48, 1)  // Error(InvalidBase)
int.to_base_string(48, 37) // Error(InvalidBase)
</code></pre>
<h3 id="javascript-note"><a class="header" href="#javascript-note">JavaScript Note</a></h3>
<p>On JavaScript targets, keep integers within ¬±(2^53 ‚àí 1) to avoid precision issues:</p>
<pre><code class="language-gleam">int.to_string(9_999_999_999_999_999)
// =&gt; "10000000000000000" on JS
// =&gt; "9999999999999999" on BEAM
</code></pre>
<p>The compiler warns when you exceed this range on the JS target.</p>
<h3 id="float-numbers"><a class="header" href="#float-numbers">Float Numbers</a></h3>
<p>Float literals:</p>
<pre><code class="language-gleam">1.5
-0.25
8.0
</code></pre>
<p>You can use underscores for clarity:</p>
<pre><code class="language-gleam">3.141_592
</code></pre>
<p>Scientific notation is also supported:</p>
<pre><code class="language-gleam">6.022e23
</code></pre>
<h3 id="float-operations"><a class="header" href="#float-operations">Float Operations</a></h3>
<p>Use <code>+.</code>, <code>-.</code>, <code>*.</code>, and <code>/.</code> for float math:</p>
<pre><code class="language-gleam">2.0 +. 3.0   // 5.0
5.0 -. 2.0   // 3.0
3.0 *. 2.0   // 6.0
4.0 /. 2.0   // 2.0
</code></pre>
<p>Dividing by zero yields <code>0.0</code>. Use <code>float.divide</code> to handle it safely:</p>
<pre><code class="language-gleam">import gleam/float

float.divide(3.0, 0.0) // Error(Nil)
</code></pre>
<p>Comparisons use float-specific operators:</p>
<pre><code class="language-gleam">2.0 &gt;. 1.0    // True
2.0 &lt;=. 2.0   // True
2.0 == 2.0    // True
2.0 != 3.0    // True
</code></pre>
<h3 id="float-helpers"><a class="header" href="#float-helpers">Float Helpers</a></h3>
<pre><code class="language-gleam">float.absolute_value(-2.5)  // 2.5
float.negate(1.0)           // -1.0
float.min(2.1, 3.3)         // 2.1
float.max(2.1, 3.3)         // 3.3
float.truncate(2.99)        // 2
float.ceiling(1.4)          // 2.0
float.floor(1.4)            // 1.0
float.round(2.5)            // 3.0
</code></pre>
<h3 id="float-power-and-root"><a class="header" href="#float-power-and-root">Float Power and Root</a></h3>
<pre><code class="language-gleam">float.power(2.0, 3.0)        // Ok(8.0)
float.power(-1.0, 0.5)       // Error(Nil)
float.square_root(4.0)       // Ok(2.0)
float.square_root(-1.0)      // Error(Nil)
</code></pre>
<p>As with integers, you must pass <code>Float</code> to these functions. Gleam doesn‚Äôt auto-cast from <code>Int</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="strings-1"><a href="#strings-1" class="header">Strings</a></h1>
<h2 id="strings"><a class="header" href="#strings">Strings</a></h2>
<p>In Gleam, strings are UTF-8 binaries. They‚Äôre immutable and store any Unicode text. Operations like length, slicing, and reversing work on <strong>graphemes</strong> (what users think of as characters), so they won‚Äôt split composed characters.</p>
<p>On the <strong>BEAM</strong> backend, Gleam uses Erlang‚Äôs Unicode-aware functions. On <strong>JavaScript</strong>, it uses UTF-16 under the hood, but the standard library ensures grapheme-level correctness.</p>
<p>Use double quotes with standard escapes (<code>\"</code>, <code>\\</code>, <code>\n</code>, <code>\t</code>, <code>\u{...}</code>). Concatenate with <code>&lt;&gt;</code>:</p>
<pre><code class="language-gleam">"Hello, Gleam!\n" &lt;&gt; "\u{1F44B}"  // "Hello, Gleam! üëã"
</code></pre>
<h3 id="emptiness-and-length"><a class="header" href="#emptiness-and-length">Emptiness and Length</a></h3>
<p><code>string.is_empty</code> checks for an empty string without allocating.
<code>string.length</code> returns the grapheme count.
<code>string.byte_size</code> gives the UTF-8 byte length.</p>
<pre><code class="language-gleam">string.is_empty("")        // True
string.length("√ü‚ÜëeÃä")       // 3 graphemes
string.byte_size("√ü‚ÜëeÃä")    // 8 bytes
</code></pre>
<h3 id="reverse"><a class="header" href="#reverse">Reverse</a></h3>
<p><code>string.reverse</code> works on graphemes:</p>
<pre><code class="language-gleam">string.reverse("stressed")  // "desserts"
</code></pre>
<h3 id="replace"><a class="header" href="#replace">Replace</a></h3>
<p><code>string.replace</code> replaces all non-overlapping <strong>literal</strong> substrings:</p>
<pre><code class="language-gleam">string.replace(in: "www.example.com", each: ".", with: "-")
// "www-example-com"
</code></pre>
<h3 id="case-conversion"><a class="header" href="#case-conversion">Case Conversion</a></h3>
<p><code>lowercase</code> and <code>uppercase</code> are Unicode-aware but not locale-sensitive:</p>
<pre><code class="language-gleam">string.lowercase("X-FILES")  // "x-files"
string.uppercase("skinner")  // "SKINNER"
</code></pre>
<h3 id="comparison"><a class="header" href="#comparison">Comparison</a></h3>
<p>Lexicographic comparison using graphemes:</p>
<pre><code class="language-gleam">string.compare("A", "B")  // order.Lt
</code></pre>
<h3 id="slicing"><a class="header" href="#slicing">Slicing</a></h3>
<p><code>slice</code> uses grapheme indices and returns <code>""</code> for out-of-bounds:</p>
<pre><code class="language-gleam">string.slice(from: "gleam", at_index: 1, length: 2)  // "le"
</code></pre>
<h3 id="cropping-and-dropping"><a class="header" href="#cropping-and-dropping">Cropping and Dropping</a></h3>
<p>Remove prefixes or graphemes:</p>
<pre><code class="language-gleam">string.crop(from: "The Lone Gunmen", before: "Lone") // "Lone Gunmen"
string.drop_start(from: "  hats", up_to: 2)          // "hats"
</code></pre>
<h3 id="contains-prefix-suffix"><a class="header" href="#contains-prefix-suffix">Contains, Prefix, Suffix</a></h3>
<p>All are case-sensitive literal checks:</p>
<pre><code class="language-gleam">string.contains(does: "theory", contain: "ory") // True
</code></pre>
<h3 id="splitting"><a class="header" href="#splitting">Splitting</a></h3>
<p><code>split</code> returns all parts, including trailing empty strings.
<code>split_once</code> stops after the first match:</p>
<pre><code class="language-gleam">string.split("a/b/c/", on: "/")          // ["a", "b", "c", ""]
string.split_once("a/b/c/", on: "/")     // Ok(#("a", "b/c/"))
</code></pre>
<h3 id="joining"><a class="header" href="#joining">Joining</a></h3>
<p><code>append</code>, <code>concat</code>, and <code>join</code> copy strings:</p>
<pre><code class="language-gleam">string.join(["home", "evan"], with: "/")  // "home/evan"
</code></pre>
<h3 id="repeat-and-pad"><a class="header" href="#repeat-and-pad">Repeat and Pad</a></h3>
<p>Work on graphemes:</p>
<pre><code class="language-gleam">string.repeat("ha", times: 3)           // "hahaha"
string.pad_start("121", to: 5, with: ".") // "..121"
</code></pre>
<h3 id="trimming"><a class="header" href="#trimming">Trimming</a></h3>
<p>Removes Unicode whitespace:</p>
<pre><code class="language-gleam">string.trim("  hats  \n")  // "hats"
</code></pre>
<h3 id="grapheme-level-access"><a class="header" href="#grapheme-level-access">Grapheme-Level Access</a></h3>
<p><code>pop_grapheme</code> and <code>to_graphemes</code> let you iterate safely:</p>
<pre><code class="language-gleam">string.pop_grapheme("gleam")  // Ok(#("g", "leam"))
</code></pre>
<h3 id="code-points"><a class="header" href="#code-points">Code Points</a></h3>
<p>Work at the Unicode scalar level:</p>
<pre><code class="language-gleam">let cps = string.to_utf_codepoints("üè≥Ô∏è‚Äçüåà")
string.from_utf_codepoints(cps)  // "üè≥Ô∏è‚Äçüåà"
</code></pre>
<h3 id="other-helpers"><a class="header" href="#other-helpers">Other Helpers</a></h3>
<pre><code class="language-gleam">string.first("icecream")        // Ok("i")
string.capitalise("mamouna")    // "Mamouna"
string.to_option("")            // None
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="tuples-and-lists"><a href="#tuples-and-lists" class="header">Tuples and lists</a></h1>
<h2 id="lists"><a class="header" href="#lists">Lists</a></h2>
<p>A list is an ordered collection of values. Lists are generic, so their type tracks the kind of elements they hold, like <code>List(Int)</code> or <code>List(String)</code>.</p>
<p>Internally, lists are immutable and singly-linked. This makes operations at the front fast and anything involving the end slower. For that reason, Gleam code usually builds lists from the front.</p>
<p>Use the <code>gleam/list</code> module for transformations like <code>map</code>, <code>filter</code>, and <code>fold</code>. This works the same on both BEAM and JavaScript targets.</p>
<h3 id="list-literals"><a class="header" href="#list-literals">List Literals</a></h3>
<p>Use square brackets. An empty list is <code>[]</code>. All elements must be the same type.</p>
<pre><code class="language-gleam">let empty_list = []
let letters = ["a", "b", "c"]
</code></pre>
<h3 id="prepend-fast"><a class="header" href="#prepend-fast">Prepend (Fast)</a></h3>
<p>Adding to the front is efficient and doesn‚Äôt copy the list.</p>
<pre><code class="language-gleam">let tail = ["b", "c"]
let full = ["a", ..tail]  // ["a", "b", "c"]
</code></pre>
<p>The <code>..</code> spread works only at the start of a list. It‚Äôs not a general-purpose concat operator.</p>
<h3 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h3>
<p>You can match on lists using <code>case</code>, useful for handling different shapes.</p>
<pre><code class="language-gleam">case letters {
  [] -&gt; "Empty"
  [x] -&gt; "One: " &lt;&gt; x
  [first, ..rest] -&gt; "First is " &lt;&gt; first
}
</code></pre>
<p>This helps cleanly separate the empty case, a single item, or a longer list.</p>
<h3 id="length-emptiness-membership"><a class="header" href="#length-emptiness-membership">Length, Emptiness, Membership</a></h3>
<pre><code class="language-gleam">import gleam/list

list.length([1, 2, 3])           // 3
list.is_empty([])                // True
list.contains(["a", "b"], "b")   // True
</code></pre>
<p>These scan the list, so avoid using them in tight loops.</p>
<h3 id="head-and-tail"><a class="header" href="#head-and-tail">Head and Tail</a></h3>
<pre><code class="language-gleam">list.first(["x", "y"])   // Ok("x")
list.rest(["x", "y"])    // Ok(["y"])
</code></pre>
<p>Both are fast and do not copy data.</p>
<h3 id="map-filter-fold"><a class="header" href="#map-filter-fold">Map, Filter, Fold</a></h3>
<pre><code class="language-gleam">list.map([1, 2], fn(x) { x + 1 })              // [2, 3]
list.filter([1, 2, 3], fn(x) { x &gt; 1 })        // [2, 3]
list.fold([1, 2, 3], 0, fn(acc, x) { acc + x }) // 6
</code></pre>
<p>These replace manual recursion for most list processing.</p>
<h3 id="find-any-all"><a class="header" href="#find-any-all">Find, Any, All</a></h3>
<pre><code class="language-gleam">list.find([1, 2, 3], fn(x) { x == 2 })   // Ok(2)
list.any([3, 5], fn(x) { x &lt; 4 })        // True
list.all([3, 5], fn(x) { x &gt; 2 })        // True
</code></pre>
<p><code>any</code> and <code>all</code> stop as soon as possible.</p>
<h3 id="zip-and-unzip"><a class="header" href="#zip-and-unzip">Zip and Unzip</a></h3>
<pre><code class="language-gleam">list.zip([1, 2], ["a", "b"])               // [#(1, "a"), #(2, "b")]
list.unzip([#(1, "x"), #(2, "y")])         // #([1, 2], ["x", "y"])
</code></pre>
<p>Use <code>strict_zip</code> if you want to fail on length mismatch.</p>
<h3 id="append-flatten-flat-map"><a class="header" href="#append-flatten-flat-map">Append, Flatten, Flat Map</a></h3>
<pre><code class="language-gleam">list.append(["a"], ["b"])                  // ["a", "b"]
list.flatten([["a"], ["b", "c"]])          // ["a", "b", "c"]
list.flat_map(["x", "y"], fn(s) { [s, "!"] }) // ["x", "!", "y", "!"]
</code></pre>
<p>Appending copies the first list, so avoid chaining it repeatedly. Use a fold and reverse for better performance.</p>
<h3 id="take-and-drop"><a class="header" href="#take-and-drop">Take and Drop</a></h3>
<pre><code class="language-gleam">list.take(["a", "b", "c"], 2)  // ["a", "b"]
list.drop(["a", "b", "c"], 1)  // ["b", "c"]
</code></pre>
<p>Both are safe and return smaller lists without error.</p>
<h3 id="unique-and-sort"><a class="header" href="#unique-and-sort">Unique and Sort</a></h3>
<pre><code class="language-gleam">list.unique(["x", "x", "y"])             // ["x", "y"]
list.sort([3, 1, 2], by: int.compare)    // [1, 2, 3]
</code></pre>
<p><code>unique</code> keeps the first of each value. <code>sort</code> needs a comparison function.</p>
<h3 id="windows-chunks-partition"><a class="header" href="#windows-chunks-partition">Windows, Chunks, Partition</a></h3>
<pre><code class="language-gleam">list.window([1, 2, 3, 4], by: 2)        // [[1,2],[2,3],[3,4]]
list.sized_chunk([1, 2, 3, 4], into: 2) // [[1,2],[3,4]]
list.partition([1, 2, 3], int.is_even)  // #([2], [1, 3])
</code></pre>
<p>Use these to split or batch data.</p>
<h3 id="ranges-and-repeats"><a class="header" href="#ranges-and-repeats">Ranges and Repeats</a></h3>
<pre><code class="language-gleam">list.range(1, 3)         // [1, 2, 3]
list.repeat("hi", 2)     // ["hi", "hi"]
</code></pre>
<p>Useful for generating test data or index sequences.</p>
<h3 id="when-not-to-use-lists"><a class="header" href="#when-not-to-use-lists">When Not to Use Lists</a></h3>
<p>If you need random access, frequent edits in the middle, or lookups by key, lists aren‚Äôt the right tool. Try <code>gleam/dict</code> for key-value data or rewrite the algorithm to use folds.</p>
<p><code>list.at</code> lets you read by index, but it‚Äôs O(n) and returns a result:</p>
<pre><code class="language-gleam">list.at(["a", "b"], 1) // Ok("b")
</code></pre>
<h2 id="tuples"><a class="header" href="#tuples">Tuples</a></h2>
<p>Tuples hold a fixed number of values. Each element can be a different type. They‚Äôre good for short groups like a result pair or coordinates.</p>
<h3 id="tuple-literals"><a class="header" href="#tuple-literals">Tuple Literals</a></h3>
<pre><code class="language-gleam">let status = #(404, "Not Found")
let config = #("dev", True, 3)
</code></pre>
<p>Each arity has a different type. A pair is not the same as a triple.</p>
<h3 id="access-by-position"><a class="header" href="#access-by-position">Access by Position</a></h3>
<pre><code class="language-gleam">status.0   // 404
status.1   // "Not Found"
config.2   // 3
</code></pre>
<p>Accessors use zero-based indexing and don‚Äôt require pattern matching.</p>
<h3 id="pattern-matching-1"><a class="header" href="#pattern-matching-1">Pattern Matching</a></h3>
<pre><code class="language-gleam">case config {
  #(env, active, tries) -&gt; env &lt;&gt; ": " &lt;&gt; int.to_string(tries)
}
</code></pre>
<p>Use matching when you want to name all fields. If the tuple has meaning in your domain, consider using a record or custom type instead.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="assignments-1"><a href="#assignments-1" class="header">Assignments</a></h1>
<h2 id="assignments"><a class="header" href="#assignments">Assignments</a></h2>
<p>Use <code>let</code> to bind values. Names use <code>snake_case</code>. Bindings are immutable, but you can bind the same name again later and shadow the previous value. This does not change the original value, it only replaces which value the name refers to.</p>
<pre><code class="language-gleam">import gleam/io

pub fn main() {
  let title = "Morning"
  io.println(title) // Morning

  let copy = title
  io.println(copy)  // Morning

  let title = "Evening"
  io.println(title) // Evening

  io.println(copy)  // Morning
}
</code></pre>
<p>If a binding is never used, the compiler warns you. Prefix the name with an underscore when this is intentional.</p>
<pre><code class="language-gleam">pub fn main() {
  let _unused_score = 500
}
</code></pre>
<p>You can add type annotations to bindings. These help with clarity and catch mismatches during type checking.</p>
<pre><code class="language-gleam">pub fn main() {
  let _label: String = "Gleam"
  let _active: Bool = True
  let _count: Int = 3
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="pattern-matching-3"><a href="#pattern-matching-3" class="header">Pattern matching</a></h1>
<h2 id="pattern-matching-2"><a class="header" href="#pattern-matching-2">Pattern Matching</a></h2>
<p>Gleam supports pattern matching in variable bindings and <code>case</code> expressions. This allows you to unpack data and handle different shapes clearly and safely.</p>
<h3 id="let-bindings"><a class="header" href="#let-bindings">Let Bindings</a></h3>
<p>With <code>let</code>, your pattern must always match the value. It‚Äôs for shapes you know are guaranteed.</p>
<pre><code class="language-gleam">pub fn main() {
  let point = #(3, 4)
  let #(x, y) = point

  io.println(int.to_string(x + y))
}
</code></pre>
<p>This works because <code>point</code> is a 2-tuple, and the pattern matches that exactly.</p>
<h3 id="case-expressions"><a class="header" href="#case-expressions">Case Expressions</a></h3>
<p>Use <code>case</code> to match multiple possible shapes. For strings, you can match a prefix using concatenation:</p>
<pre><code class="language-gleam">import gleam/io

pub fn main() {
  io.println(get_name("Hello, Joe"))
  io.println(get_name("Hello, Mike"))
  io.println(get_name("System still working?"))
}

fn get_name(x: String) -&gt; String {
  case x {
    "Hello, " &lt;&gt; name -&gt; name
    _ -&gt; "Unknown"
  }
}
</code></pre>
<p>Lists can be matched by length or contents. The <code>..</code> syntax captures the remaining elements:</p>
<pre><code class="language-gleam">import gleam/int
import gleam/list
import gleam/io

pub fn main() {
  let xs = list.repeat(int.random(5), times: int.random(3))

  let result = case xs {
    [] -&gt; "Empty list"
    [1] -&gt; "List of just 1"
    [4, ..] -&gt; "List starting with 4"
    [_, _] -&gt; "List of 2 elements"
    _ -&gt; "Some other list"
  }

  io.println(result)
}
</code></pre>
<h3 id="let-assert"><a class="header" href="#let-assert">Let Assert</a></h3>
<p>Use <code>let assert</code> when you expect a certain shape and want the program to fail fast if that shape isn‚Äôt matched. It allows partial patterns and will panic if the match fails. You can add a custom message.</p>
<pre><code class="language-gleam">pub fn main() {
  let a = unsafely_get_first_element([123])
  io.println(int.to_string(a))

  let b = unsafely_get_first_element([])
  io.println(int.to_string(b))  // Panics here
}

pub fn unsafely_get_first_element(items: List(a)) -&gt; a {
  let assert [first, ..] = items as "List should not be empty"
  first
}
</code></pre>
<p>Use this only when you‚Äôre certain about the input, or when failing is acceptable.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="functions-1"><a href="#functions-1" class="header">Functions</a></h1>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>Use <code>fn</code> to define a function. Gleam runs the body top to bottom and returns the final value. There‚Äôs no <code>return</code> keyword.</p>
<p>Functions are private unless marked <code>pub</code>. Type annotations help with clarity but aren‚Äôt required.</p>
<pre><code class="language-gleam">pub fn main() {
  greet("Alex")
}

fn greet(name: String) {
  let message = make_message(name)
  io.println(message)
}

fn make_message(name: String) -&gt; String {
  "Welcome, " &lt;&gt; name &lt;&gt; "!"
}
</code></pre>
<h3 id="higher-order-functions"><a class="header" href="#higher-order-functions">Higher-Order Functions</a></h3>
<p>Functions can be passed around like any other value. You can use them to build flexible logic.</p>
<pre><code class="language-gleam">pub fn main() {
  let result = apply_twice(square, 3)
  io.println(int.to_string(result))
}

fn square(n: Int) -&gt; Int {
  n * n
}

fn apply_twice(f: fn(Int) -&gt; Int, x: Int) -&gt; Int {
  f(f(x))
}
</code></pre>
<h3 id="anonymous-functions"><a class="header" href="#anonymous-functions">Anonymous Functions</a></h3>
<p>You can define unnamed functions inline. These can also capture values from their environment.</p>
<pre><code class="language-gleam">pub fn main() {
  let double = fn(n) { n * 2 }
  let result = double_and_add(double, 5)
  io.println(int.to_string(result))

  let base = 10
  let add_base = fn(x) { x + base }
  io.println(int.to_string(add_base(5)))
}

fn double_and_add(f: fn(Int) -&gt; Int, x: Int) -&gt; Int {
  f(x) + x
}
</code></pre>
<h3 id="function-captures"><a class="header" href="#function-captures">Function Captures</a></h3>
<p>Use <code>_</code> to partially apply a function and create a new one.</p>
<pre><code class="language-gleam">pub fn main() {
  let greet = say("Hi", _)
  io.println(greet("Sam"))
}

fn say(prefix: String, name: String) -&gt; String {
  prefix &lt;&gt; ", " &lt;&gt; name
}
</code></pre>
<p>This simplifies your code and makes pipelines easier to read.</p>
<h3 id="generic-functions"><a class="header" href="#generic-functions">Generic Functions</a></h3>
<p>Generic functions work with any type, as long as it‚Äôs consistent within the call.</p>
<pre><code class="language-gleam">pub fn main() {
  io.println(duplicate("hey"))
  io.println(int.to_string(duplicate(42)))
}

fn duplicate(x: value) -&gt; Tuple(value, value) {
  #(x, x)
}
</code></pre>
<p>The compiler ensures the types are used consistently and doesn‚Äôt allow mismatches.</p>
<h3 id="pipelines"><a class="header" href="#pipelines">Pipelines</a></h3>
<p>The pipe operator passes the result of one expression into the next. It improves readability by following the data flow.</p>
<pre><code class="language-gleam">import gleam/string
import gleam/io

pub fn main() {
  "   Hello World!  "
  |&gt; string.trim
  |&gt; string.uppercase
  |&gt; string.append("!!!")
  |&gt; io.println
}
</code></pre>
<p>You can also use <code>_</code> to place the piped value into another argument slot.</p>
<pre><code class="language-gleam">"42"
|&gt; string.concat(["Value: ", _])
|&gt; io.println
</code></pre>
<h3 id="labelled-arguments"><a class="header" href="#labelled-arguments">Labelled Arguments</a></h3>
<p>Labels help show what each argument means. They‚Äôre useful when multiple arguments share a type.</p>
<pre><code class="language-gleam">pub fn main() {
  let total = compute_cost(units: 4, price_per_unit: 25)
  io.println(int.to_string(total))
}

fn compute_cost(units units: Int, price_per_unit cost: Int) -&gt; Int {
  units * cost
}
</code></pre>
<p>Labels can be written in any order at the call site.</p>
<h3 id="label-shorthand"><a class="header" href="#label-shorthand">Label Shorthand</a></h3>
<p>If your variable names match the parameter labels, you can use shorthand syntax.</p>
<pre><code class="language-gleam">pub fn main() {
  let width = 10
  let height = 5
  let unit = "cm"

  describe_rectangle(width:, height:, unit:)
}

fn describe_rectangle(
  width width: Int,
  height height: Int,
  unit unit: String,
) {
  let info = int.to_string(width) &lt;&gt; " x " &lt;&gt;
             int.to_string(height) &lt;&gt; " " &lt;&gt;
             unit

  io.println(info)
}
</code></pre>
<p>This keeps function calls compact and clear.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="result-and-optional-types"><a href="#result-and-optional-types" class="header">Result and optional types</a></h1>
<h2 id="handling-absence-and-failure"><a class="header" href="#handling-absence-and-failure">Handling absence and failure</a></h2>
<p>Gleam uses two types to handle missing values and fallible operations: <code>Option(a)</code> and <code>Result(a, e)</code>. These types make uncertainty explicit and force you to handle it clearly.</p>
<h3 id="option-type"><a class="header" href="#option-type">Option Type</a></h3>
<p>Use <code>Option(a)</code> for values that might be missing. For example, an optional parameter or a field that may be absent:</p>
<pre><code class="language-gleam">import gleam/option.{type Option, Some, None}

pub type User {
  User(name: String, nickname: Option(String))
}

let user1 = User("Eva", Some("E"))
let user2 = User("Tom", None)
</code></pre>
<h4 id="optionmap"><a class="header" href="#optionmap"><code>option.map</code></a></h4>
<p>Transforms the inner value if it‚Äôs present:</p>
<pre><code class="language-gleam">option.map(Some(2), fn(x) { x * 3 }) // Some(6)
option.map(None, fn(x) { x * 3 })    // None
</code></pre>
<h4 id="optionthen"><a class="header" href="#optionthen"><code>option.then</code></a></h4>
<p>Chains computations that return <code>Option</code>:</p>
<pre><code class="language-gleam">option.then(Some(2), fn(x) { Some(x + 1) }) // Some(3)
option.then(Some(2), fn(_) { None })        // None
option.then(None, fn(x) { Some(x + 1) })    // None
</code></pre>
<h4 id="optionor-and-optionlazy_or"><a class="header" href="#optionor-and-optionlazy_or"><code>option.or</code> and <code>option.lazy_or</code></a></h4>
<p>Use fallback options:</p>
<pre><code class="language-gleam">option.or(Some(1), Some(2))               // Some(1)
option.or(None, Some(2))                  // Some(2)
option.lazy_or(Some(1), fn() { Some(3) }) // Some(1)
option.lazy_or(None, fn() { Some(3) })    // Some(3)
</code></pre>
<h4 id="optionunwrap"><a class="header" href="#optionunwrap"><code>option.unwrap</code></a></h4>
<p>Extract the value or use a default:</p>
<pre><code class="language-gleam">option.unwrap(Some(5), 0) // 5
option.unwrap(None, 0)    // 0
</code></pre>
<h4 id="optionflatten"><a class="header" href="#optionflatten"><code>option.flatten</code></a></h4>
<p>Removes one layer of nesting:</p>
<pre><code class="language-gleam">option.flatten(Some(Some(1))) // Some(1)
option.flatten(Some(None))    // None
option.flatten(None)          // None
</code></pre>
<h4 id="optionto_result"><a class="header" href="#optionto_result"><code>option.to_result</code></a></h4>
<p>Converts an <code>Option</code> into a <code>Result</code>:</p>
<pre><code class="language-gleam">option.to_result(Some(5), "missing") // Ok(5)
option.to_result(None, "missing")    // Error("missing")
</code></pre>
<h3 id="result-types"><a class="header" href="#result-types">Result Types</a></h3>
<p>Use <code>Result(a, e)</code> when a function can fail. This forces the caller to handle both the success and error cases.</p>
<pre><code class="language-gleam">fn parse_number(s: String) -&gt; Result(Int, String) {
  case int.parse(s) {
    Ok(n) -&gt; Ok(n)
    Error(_) -&gt; Error("invalid input")
  }
}
</code></pre>
<h4 id="resultmap"><a class="header" href="#resultmap"><code>result.map</code></a></h4>
<p>Transforms the success value:</p>
<pre><code class="language-gleam">result.map(Ok(2), fn(x) { x * 2 })     // Ok(4)
result.map(Error("bad"), fn(x) { x })  // Error("bad")
</code></pre>
<h4 id="resulttry"><a class="header" href="#resulttry"><code>result.try</code></a></h4>
<p>Chains fallible functions:</p>
<pre><code class="language-gleam">fn safe_parse(s: String) -&gt; Result(Int, String) {
  case int.parse(s) {
    Ok(n) -&gt; Ok(n)
    Error(_) -&gt; Error("not a number")
  }
}

result.try(Ok("42"), safe_parse)   // Ok(42)
result.try(Ok("foo"), safe_parse)  // Error("not a number")
result.try(Error("fail"), safe_parse) // Error("fail")
</code></pre>
<h4 id="resultunwrap"><a class="header" href="#resultunwrap"><code>result.unwrap</code></a></h4>
<p>Returns the success value or a fallback:</p>
<pre><code class="language-gleam">result.unwrap(Ok("done"), "default")    // "done"
result.unwrap(Error("fail"), "default") // "default"
</code></pre>
<h4 id="resultis_ok-and-resultis_error"><a class="header" href="#resultis_ok-and-resultis_error"><code>result.is_ok</code> and <code>result.is_error</code></a></h4>
<p>Check what variant you‚Äôre working with:</p>
<pre><code class="language-gleam">result.is_ok(Ok(1))       // True
result.is_error(Ok(1))    // False
result.is_error(Error(1)) // True
</code></pre>
<h4 id="resultall"><a class="header" href="#resultall"><code>result.all</code></a></h4>
<p>Collects a list of <code>Result</code>s into one <code>Result</code> with a list:</p>
<pre><code class="language-gleam">result.all([Ok(1), Ok(2)])        // Ok([1, 2])
result.all([Ok(1), Error("x")])   // Error("x")
</code></pre>
<h4 id="resultlazy_or"><a class="header" href="#resultlazy_or"><code>result.lazy_or</code></a></h4>
<p>Provides a fallback result lazily:</p>
<pre><code class="language-gleam">result.lazy_or(Ok(1), fn() { Ok(2) })          // Ok(1)
result.lazy_or(Error("e"), fn() { Ok(2) })     // Ok(2)
result.lazy_or(Error("e"), fn() { Error("x") }) // Error("x")
</code></pre>
<h3 id="when-to-use-each"><a class="header" href="#when-to-use-each">When to Use Each</a></h3>
<p>In other languages fallible functions may return either <code>Result</code> or <code>Option</code> depending on whether there is more information to be given about the failure. In Gleam all fallible functions return <code>Result</code>, and <code>Nil</code> is used as the error if there is no extra detail to give.</p>
<p>This consistency removes the boilerplate that would otherwise be needed to convert between <code>Option</code> and <code>Result</code> types, and makes APIs more predictable:</p>
<pre><code class="language-gleam">import gleam/option
import gleam/result
import gleam/int
import gleam/io

fn apply_multiplier(value: Int, maybe: Option(Int)) -&gt; Int {
  case maybe {
    Some(m) -&gt; value * m
    None -&gt; value
  }
}

fn parse_positive(s: String) -&gt; Result(Int, Nil) {
  case int.parse(s) {
    Ok(n) if n &gt; 0 -&gt; Ok(n)
    _ -&gt; Error(Nil)
  }
}

pub fn main() {
  let maybe_multiplier = Some(2)

  case parse_positive("10") {
    Ok(n) -&gt;
      let result = apply_multiplier(n, maybe_multiplier)
      io.println(int.to_string(result))
    Error(_) -&gt;
      io.println("Invalid input")
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="expression-blocks-1"><a href="#expression-blocks-1" class="header">Expression blocks</a></h1>
<h2 id="expression-blocks"><a class="header" href="#expression-blocks">Expression Blocks</a></h2>
<pre><code>error: Syntax error  
  ‚îå‚îÄ /Users/adi.salimgereyev/hello_world/src/hello_world.gleam:8:10  
  ‚îÇ  
8 ‚îÇ     let b = (1 + 2) * 3  
  ‚îÇ             ^ This parenthesis cannot be understood here

Hint: To group expressions in Gleam, use "{" and "}"; tuples are created with `#(` and `)`.
</code></pre>
<p>In Gleam you group expressions with <code>{}</code>. A block runs its expressions in order and evaluates to the last one. Names bound inside the block are scoped to that block.</p>
<pre><code class="language-gleam">pub fn area_of_square(size: Int) -&gt; Int {
  let perimeter = {
    let doubled = size * 2
    doubled * 2
  }
  
  perimeter * size / 4
}
</code></pre>
<p>Blocks can change evaluation order. Wrap a subexpression in <code>{}</code> when you want it to run first:</p>
<pre><code class="language-gleam">// Default precedence gives 7
let a = 1 + 2 * 3

// Run 1 + 2 first, gives 9
let b = { 1 + 2 } * 3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="panic-and-assert"><a href="#panic-and-assert" class="header">Panic and assert</a></h1>
<h2 id="assertions-and-panic"><a class="header" href="#assertions-and-panic">Assertions and panic</a></h2>
<p>You already saw <code>let assert</code> earlier. It binds with a partial pattern and crashes if the value does not match. We use it for invariants we consider impossible to violate, and prefer returning a <code>Result</code> in library code so the caller can decide what to do.</p>
<p><code>panic</code> crashes immediately. It is for code paths that must never run, such as unreachable branches or unimplemented cases. Add a message with <code>as "..."</code> so failures are clear:</p>
<pre><code class="language-gleam">import gleam/io
import gleam/int

pub fn describe(score: Int) {
  case score {
    s if s &gt; 1000 -&gt; io.println("High score!")
    s if s &gt; 0 -&gt; io.println("Still working on it")
    _ -&gt; panic as "Scores should never be negative!"
  }
}
</code></pre>
<p><code>assert</code> is another way to cause a panic. It checks that a boolean expression evaluates to <code>True</code>. Like the others, you can add a custom message with <code>as</code>. This replaces the generic message when the assertion fails. Do not use <code>assert</code> in applications or libraries. Keep it in tests:</p>
<pre><code class="language-gleam">pub fn add_test() {
  assert add(1, 2) == 3
  assert add(1, 2) &lt; add(1, 3)
  assert add(6, 2) == add(2, 6) as "Addition should be commutative"
  assert add(2, 2) == 5
}

fn add(a: Int, b: Int) -&gt; Int {
  a + b
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="custom-types-1"><a href="#custom-types-1" class="header">Custom types</a></h1>
<h2 id="custom-types"><a class="header" href="#custom-types">Custom types</a></h2>
<p>Custom types let you model ‚Äúthis or that‚Äù choices with named constructors. A value of a custom type is one of its constructors, and you handle each case with <code>case</code>. This is a sum type, also called an algebraic data type.</p>
<pre><code class="language-gleam">pub type Shape {
  Circle(radius: Float)
  Rectangle(width: Float, height: Float)
}

fn area(s: Shape) -&gt; Float {
  case s {
    Circle(radius:) -&gt; 3.14159 *. radius *. radius
    Rectangle(width:, height:) -&gt; width *. height
  }
}
</code></pre>
<p>You define the type with <code>type</code>, give each variant a constructor, then pattern match by constructor.</p>
<p>A constructor that carries fields is called a record. You can read fields with dot syntax and update immutably with record update. This keeps data immutable and clear to read.</p>
<pre><code class="language-gleam">pub type User {
  User(name: String, age: Int)
}

pub fn main() {
  let u1 = User("Bea", 28)
  let u2 = User(..u1, age: 29)
  let name = u2.name
  
  io.println(name) // Bea
}
</code></pre>
<p>You can match on records to pull out fields or add guards. This keeps branching logic tight and local. The <code>let</code> form can destructure single-variant types, and <code>case</code> works for any variant set.</p>
<pre><code class="language-gleam">fn can_vote(u: User) -&gt; Bool {
  case u {
    User(age: a) if a &gt;= 18 -&gt; True
    _ -&gt; False
  }
}
</code></pre>
<p>Custom types can be generic. Write type variables in lowercase. This gives you reuse without losing static checks. Gleam‚Äôs own <code>Option(a)</code> and <code>Result(a, e)</code> follow this shape.</p>
<pre><code class="language-gleam">pub type Box(value) { 
  Box(value) 
}

fn map_box(x: Box(a), f: fn(a) -&gt; b) -&gt; Box(b) {
  case x { 
    Box(v) -&gt; Box(f(v))
  }
}
</code></pre>
<p>When you need invariants, make the type opaque. Export the type, keep its constructors private, and expose smart constructors and getters. Callers can use the type but cannot forge or deconstruct it:</p>
<pre><code class="language-gleam">pub opaque type Id { 
  Id(value: String) 
}

pub fn from_string(s: String) -&gt; Id {
  Id(s)
}

pub fn to_string(id: Id) -&gt; String {
  id.value
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="modules-and-imports"><a class="header" href="#modules-and-imports">Modules and imports</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="advanced-gleam"><a class="header" href="#advanced-gleam">Advanced Gleam</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="todo"><a class="header" href="#todo">Todo</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="bit-strings"><a class="header" href="#bit-strings">Bit strings</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="escape-sequences"><a class="header" href="#escape-sequences">escape sequences</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="tail-call-optimisation"><a class="header" href="#tail-call-optimisation">Tail call optimisation</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="phantom-types"><a class="header" href="#phantom-types">Phantom types</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="labelled-arguments-1"><a class="header" href="#labelled-arguments-1">Labelled arguments</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="labelled-fields"><a class="header" href="#labelled-fields">Labelled fields</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="dict"><a class="header" href="#dict">Dict</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="pairs"><a class="header" href="#pairs">Pairs</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="sets"><a class="header" href="#sets">Sets</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="option"><a class="header" href="#option">Option</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="order"><a class="header" href="#order">Order</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="iterator"><a class="header" href="#iterator">Iterator</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="opaque-types"><a class="header" href="#opaque-types">Opaque types</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="queue"><a class="header" href="#queue">Queue</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="erlang-and-javascript-interop"><a class="header" href="#erlang-and-javascript-interop">Erlang and Javascript interop</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="bytes-and-string-builders"><a class="header" href="#bytes-and-string-builders">Bytes and string builders</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="base64"><a class="header" href="#base64">Base64</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="regex"><a class="header" href="#regex">Regex</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="uri"><a class="header" href="#uri">URI</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ecosystem"><a class="header" href="#ecosystem">Ecosystem</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="installing-custom-packages"><a class="header" href="#installing-custom-packages">Installing custom packages</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="creating-and-publishing-a-package"><a class="header" href="#creating-and-publishing-a-package">Creating and publishing a package</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="gleam-docker-images"><a class="header" href="#gleam-docker-images">Gleam docker images</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="simplifile-package"><a class="header" href="#simplifile-package">Simplifile package</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="filepath-filepath"><a class="header" href="#filepath-filepath">Filepath: filepath</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ranges-ranger"><a class="header" href="#ranges-ranger">Ranges: ranger</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="datetime-birl"><a class="header" href="#datetime-birl">Datetime: birl</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ad-hoc-error-type-snag"><a class="header" href="#ad-hoc-error-type-snag">Ad-hoc error type: snag</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="json-gleam_json"><a class="header" href="#json-gleam_json">Json: gleam_json</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="gleam_crypto"><a class="header" href="#gleam_crypto">gleam_crypto</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-5a2b5dad.js"></script>
        <script src="book-9576a2db.js"></script>

        <!-- Custom JS scripts -->
        <script src="syntax-1451bcbd.js"></script>
        <script src="highlight-5a2b5dad.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
